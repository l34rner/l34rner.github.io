<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="理解JS中的预编译、作用域链和闭包"><meta name="keywords" content="学习篇·化无炼有"><meta name="author" content="Expvul.0D,undefined"><meta name="copyright" content="Expvul.0D"><title>理解JS中的预编译、作用域链和闭包【Exploit this vulnerable world】</title><link rel="stylesheet" href="/css/fan.css"><link rel="stylesheet" href="/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="icon" href="/sec.ico"><!-- script(src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML")--><script src="/js/mathjax/mathjax.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
});
</script><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
}</script></head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="toggle-sidebar-info button-hover"><span data-toggle="文章目录">站点概览</span></div><div class="sidebar-toc"><div class="sidebar-toc-title">目录</div><div class="sidebar-toc-progress"><span class="progress-notice">您已阅读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc-progress-bar"></div></div><div class="sidebar-toc-content" id="sidebar-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#函数预编译"><span class="toc-number">1.</span> <span class="toc-text">函数预编译</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#作用域链"><span class="toc-number">2.</span> <span class="toc-text">作用域链</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#闭包"><span class="toc-number">3.</span> <span class="toc-text">闭包</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/pic.jpg"></div><div class="author-info-name">Expvul.0D</div><div class="author-info-description"></div><div class="links-buttons"><a class="links-button button-hover" href="https://github.com/l34rner" target="_blank">GitHub<i class="icon-dot bg-color2"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="/archives"><span class="pull-top">日志</span><span class="pull-bottom">4</span></a><a class="author-info-articles-tags article-meta" href="/tags"><span class="pull-top">标签</span><span class="pull-bottom">1</span></a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/">首页</a><a class="menu-item" href="/tags">标签</a><a class="menu-item" href="/categories">分类</a><a class="menu-item" href="/archives">归档</a><a class="menu-item" href="/about">关于</a></nav><div class="right-info"><a class="title-name" href="/">Exploit this vulnerable world</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><article id="post"><div class="post-header"><div class="title">理解JS中的预编译、作用域链和闭包</div><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 发表于 2020-01-04 | 更新于 2020-01-04</time><!--time.button-hover.post-date #[i.fas.fa-calendar-alt.article-icon(aria-hidden="true")] #[=__('post.modified')] #[=date(page['updated'], config.date_format)]--><div class="button-hover categories"></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AF%87%C2%B7%E5%8C%96%E6%97%A0%E7%82%BC%E6%9C%89/">学习篇·化无炼有</a></div></div></div><div class="main-content"><p>进入正题之前，先看这么一段代码，考虑一下代码的执行结果是什么。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);</span></pre></td></tr></table></figure>

<p>问题答案还是很明显的，只要了解JS中”函数声明提升”这个概念的话，就很容易得出结论是打印出函数体，如下所示：</p>
<p><img src="/2020/01/04/%E7%90%86%E8%A7%A3JS%E4%B8%AD%E7%9A%84%E9%A2%84%E7%BC%96%E8%AF%91%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/.%5C%E7%90%86%E8%A7%A3JS%E4%B8%AD%E7%9A%84%E9%A2%84%E7%BC%96%E8%AF%91%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85%5Cimage-20200104104909270.png" alt="image-20200104104909270"></p>
<p>接下来，情况变得复杂一点，考虑这段代码的执行结果</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a</span>)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">console</span>.log(a);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">var</span> a=<span class="number">123</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">console</span>.log(a);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">console</span>.log(a);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">var</span> b=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">console</span>.log(b);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">d</span>(<span class="params"></span>)</span>&#123;&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">fn(<span class="number">1</span>);</span></pre></td></tr></table></figure>

<p>如果只知道变量提升和函数提升的话，这段代码的执行结果就不太好分析出结论了。这里其实牵涉到的一个概念是函数预编译。</p>
<h2 id="函数预编译"><a href="#函数预编译" class="headerlink" title="函数预编译"></a>函数预编译</h2><p>预编译发生在函数执行的前一刻，预编译的过程中创建了一个执行期上下文，简称AO对象，整个预编译的过程有如下几个步骤：</p>
<ol>
<li>创建AO对象</li>
<li>找形参和变量声明，将其作为AO对象的属性，值为undefined</li>
<li>将实参传递给形参</li>
<li>在函数体内找函数声明，函数名作为AO对象的属性名，值为函数体</li>
</ol>
<p>整个预编译的过程是按1-4的步骤顺序执行的。有了这个理论基础，就可以来分析上面那段代码了。首先创建AO对象，即：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">AO:&#123;&#125;</span></pre></td></tr></table></figure>

<p>然后执行第2步，形参是a，函数体内还有变量声明a、b，但是作为对象的属性，不可能存在同名属性，所以不会有两个a，第2步执行完的结果是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">AO:&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">	a:undefined,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">	b:undefined</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>第3步，实参传值，这里实参值是1，所以第3步执行完之后AO对象为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">AO:&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">	a:1,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">	b:undefined</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>第4步，找函数声明，函数名为属性名，值为函数体。fn中有两个函数声明分别是a和d，所以第4步执行完之后的AO对象为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">AO:&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">	a:function a()&#123;&#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">	b:undefined,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">	d:function d()&#123;&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>预编译到此结束，然后是开始执行函数，第一个console.log(a)，毫无疑问就是打印函数体，然后是var a=123;其实var a在预编译阶段已经完成，此时只是进行赋值操作，所以a的值变成了123，所以接下来的console.log(a)打印的就是123，再接着是函数a的定义，这个在预编译阶段已经完成了，所以直接跳过，又到了console.log(a)，还是打印123，然后是var b=function(){}同样的var b在预编译阶段已经处理完毕，此时是对b赋值，搜索console.log(b)打印的是函数体，最后的函数d声明在预编译阶段执行完毕，直接跳过，到此fn执行结束，结果如下：</p>
<p><img src="/2020/01/04/%E7%90%86%E8%A7%A3JS%E4%B8%AD%E7%9A%84%E9%A2%84%E7%BC%96%E8%AF%91%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/.%5C%E7%90%86%E8%A7%A3JS%E4%B8%AD%E7%9A%84%E9%A2%84%E7%BC%96%E8%AF%91%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85%5Cimage-20200104110602676.png" alt="image-20200104110602676"></p>
<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>对象除了有显式属性，还有隐式属性，隐式属性程序员无法调用，是由JS引擎调用的，比如某函数名为test，那么test.[[scope]]就是个隐式属性，表示由函数的产生而产生的作用域，是运行期上下文的集合。</p>
<p>函数执行的前一刻会创建一个执行期上下文对象，也就是上面所说的AO对象，一个执行期上下文定义了一个函数执行是的环境，函数每次执行时对应的上下文都是独一无二的，多次调用一个函数会创建多个上下文，函数执行完毕后会销毁AO，但是只销毁函数自己产生的AO，不会销毁其他函数的AO。由于[[scope]]中存储的集合是个链式结构，所以称为作用域链。</p>
<p>接下来还是代码举例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">var</span> b=<span class="number">234</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">var</span> a=<span class="number">123</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    b();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> global=<span class="number">100</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">a();</span></pre></td></tr></table></figure>

<p>a函数刚被定义时，a的scope中只有一个a所在环境的执行上下文，这个环境是指全局，如下所示：</p>
<p><img src="/2020/01/04/%E7%90%86%E8%A7%A3JS%E4%B8%AD%E7%9A%84%E9%A2%84%E7%BC%96%E8%AF%91%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/.%5C%E7%90%86%E8%A7%A3JS%E4%B8%AD%E7%9A%84%E9%A2%84%E7%BC%96%E8%AF%91%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85%5Cimage-20200104112915548.png" alt="image-20200104112915548"></p>
<p>a函数执行时，要产生一个执行期上下文，这个AO会被放到a的scope chain的顶端。</p>
<p><img src="/2020/01/04/%E7%90%86%E8%A7%A3JS%E4%B8%AD%E7%9A%84%E9%A2%84%E7%BC%96%E8%AF%91%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/.%5C%E7%90%86%E8%A7%A3JS%E4%B8%AD%E7%9A%84%E9%A2%84%E7%BC%96%E8%AF%91%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85%5Cimage-20200104113622718.png" alt="image-20200104113622718"></p>
<p>当一个函数要使用某个变量时，就会在这个函数的作用域链中自上而下查找。b函数被创建时，由于b是在a中定义的，所以b的环境除了全局，还有a的执行环境（这也是为什么内部函数可以使用外层函数中定义的变量）。</p>
<p><img src="/2020/01/04/%E7%90%86%E8%A7%A3JS%E4%B8%AD%E7%9A%84%E9%A2%84%E7%BC%96%E8%AF%91%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/.%5C%E7%90%86%E8%A7%A3JS%E4%B8%AD%E7%9A%84%E9%A2%84%E7%BC%96%E8%AF%91%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85%5Cimage-20200104114136293.png" alt="image-20200104114136293"></p>
<p>当b函数被执行时，又会生成一个专属于b的AO，被放置到b的作用域链的顶端，如下：</p>
<p><img src="/2020/01/04/%E7%90%86%E8%A7%A3JS%E4%B8%AD%E7%9A%84%E9%A2%84%E7%BC%96%E8%AF%91%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/.%5C%E7%90%86%E8%A7%A3JS%E4%B8%AD%E7%9A%84%E9%A2%84%E7%BC%96%E8%AF%91%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85%5Cimage-20200104114631066.png" alt="image-20200104114631066"></p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>理解了作用域链，就容易理解闭包了，所谓闭包，简单来说就是将内部函数返回，置于全局环境中，由于内部函数返回出来，会保持自己的作用域链，所以依然可以访问原来的外层函数中声明的变量。闭包的一个效果就是保持原来的作用域链不释放，负面影响是容易造成内存泄露。</p>
</div><div class="post-copyright"><div class="post-copyright-author"><span class="post-copyright-meta">本文作者: </span><span class="post-copyright-info"><a href="mailto:undefined" target="_blank" rel="noopener">Expvul.0D</a></span></div><div class="post-copyright-type"><span class="post-copyright-meta">本文链接: </span><span class="post-copyright-info"><a href="/https:/www.expvul0d.com/2020/01/04/%E7%90%86%E8%A7%A3JS%E4%B8%AD%E7%9A%84%E9%A2%84%E7%BC%96%E8%AF%91%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/">https://www.expvul0d.com/2020/01/04/%E7%90%86%E8%A7%A3JS%E4%B8%AD%E7%9A%84%E9%A2%84%E7%BC%96%E8%AF%91%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/</a></span></div><div class="post-copyright-notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.expvul0d.com">Exploit this vulnerable world</a>！</span></div></div></article><div id="pagination"><div class="next-post pull-right"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/2019/12/21/Java-Annotation/"><span>Java Annotation</span><span>&nbsp;</span><i class="fas fa-angle-right"></i></a></div></div><!--div!= paginator()--></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fas fa-file-o"></i></span><span id="busuanzi_value_page_pv"></span><span></span></div><div class="copyright">&copy;2017 ～ 2020 By Expvul.0D</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/copy.js"></script><!--script(src=url)--></body></html>