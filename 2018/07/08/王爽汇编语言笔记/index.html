<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="王爽汇编语言笔记"><meta name="keywords" content="学习篇·化无炼有"><meta name="author" content="l34rner,undefined"><meta name="copyright" content="l34rner"><title>王爽汇编语言笔记【一个记录自己学习轨迹的自娱自乐之地】</title><link rel="stylesheet" href="/css/fan.css"><link rel="stylesheet" href="/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="icon" href="/sec.ico"><!-- script(src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML")--><script src="/js/mathjax/mathjax.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
});
</script><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
}</script></head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="toggle-sidebar-info button-hover"><span data-toggle="文章目录">站点概览</span></div><div class="sidebar-toc"><div class="sidebar-toc-title">目录</div><div class="sidebar-toc-progress"><span class="progress-notice">您已阅读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc-progress-bar"></div></div><div class="sidebar-toc-content" id="sidebar-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#第1章-基础知识"><span class="toc-number">1.</span> <span class="toc-text">第1章 基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#机器语言"><span class="toc-number">1.1.</span> <span class="toc-text">机器语言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#汇编语言"><span class="toc-number">1.2.</span> <span class="toc-text">汇编语言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#存储器"><span class="toc-number">1.3.</span> <span class="toc-text">存储器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#指令和数据"><span class="toc-number">1.4.</span> <span class="toc-text">指令和数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#存储单元"><span class="toc-number">1.5.</span> <span class="toc-text">存储单元</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CPU对存储器的读写"><span class="toc-number">1.6.</span> <span class="toc-text">CPU对存储器的读写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#地址总线"><span class="toc-number">1.7.</span> <span class="toc-text">地址总线</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据总线"><span class="toc-number">1.8.</span> <span class="toc-text">数据总线</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#控制总线"><span class="toc-number">1.9.</span> <span class="toc-text">控制总线</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内存地址空间"><span class="toc-number">1.10.</span> <span class="toc-text">内存地址空间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#接口卡"><span class="toc-number">1.11.</span> <span class="toc-text">接口卡</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#各类存储器芯片"><span class="toc-number">1.12.</span> <span class="toc-text">各类存储器芯片</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第2章-寄存器"><span class="toc-number">2.</span> <span class="toc-text">第2章 寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#通用寄存器"><span class="toc-number">2.1.</span> <span class="toc-text">通用寄存器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字在寄存器中的存储"><span class="toc-number">2.2.</span> <span class="toc-text">字在寄存器中的存储</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#几条汇编指令"><span class="toc-number">2.3.</span> <span class="toc-text">几条汇编指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#物理地址"><span class="toc-number">2.4.</span> <span class="toc-text">物理地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16位的CPU结构"><span class="toc-number">2.5.</span> <span class="toc-text">16位的CPU结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8086CPU给出物理地址的方法"><span class="toc-number">2.6.</span> <span class="toc-text">8086CPU给出物理地址的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#段地址-16-偏移地址-物理地址的本质含义"><span class="toc-number">2.7.</span> <span class="toc-text">段地址*16+偏移地址=物理地址的本质含义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#段的概念"><span class="toc-number">2.8.</span> <span class="toc-text">段的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#段寄存器"><span class="toc-number">2.9.</span> <span class="toc-text">段寄存器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CS和IP"><span class="toc-number">2.10.</span> <span class="toc-text">CS和IP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#修改CS、IP的指令"><span class="toc-number">2.11.</span> <span class="toc-text">修改CS、IP的指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#代码段"><span class="toc-number">2.12.</span> <span class="toc-text">代码段</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第3章-寄存器（内存访问）"><span class="toc-number">3.</span> <span class="toc-text">第3章 寄存器（内存访问）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#内存中字的存储"><span class="toc-number">3.1.</span> <span class="toc-text">内存中字的存储</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DS和-address"><span class="toc-number">3.2.</span> <span class="toc-text">DS和[address]</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字的传送"><span class="toc-number">3.3.</span> <span class="toc-text">字的传送</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mov、add、sub指令"><span class="toc-number">3.4.</span> <span class="toc-text">mov、add、sub指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据段"><span class="toc-number">3.5.</span> <span class="toc-text">数据段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#栈"><span class="toc-number">3.6.</span> <span class="toc-text">栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CPU提供的栈机制"><span class="toc-number">3.7.</span> <span class="toc-text">CPU提供的栈机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#栈顶超界的问题"><span class="toc-number">3.8.</span> <span class="toc-text">栈顶超界的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#push、pop指令"><span class="toc-number">3.9.</span> <span class="toc-text">push、pop指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#栈段"><span class="toc-number">3.10.</span> <span class="toc-text">栈段</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第4章-第一个程序"><span class="toc-number">4.</span> <span class="toc-text">第4章 第一个程序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#一个源程序从写出到执行的过程"><span class="toc-number">4.1.</span> <span class="toc-text">一个源程序从写出到执行的过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#源程序"><span class="toc-number">4.2.</span> <span class="toc-text">源程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#伪指令"><span class="toc-number">4.2.1.</span> <span class="toc-text">伪指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#end"><span class="toc-number">4.2.2.</span> <span class="toc-text">end</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#assume"><span class="toc-number">4.2.3.</span> <span class="toc-text">assume</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#标号"><span class="toc-number">4.2.4.</span> <span class="toc-text">标号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#程序返回"><span class="toc-number">4.2.5.</span> <span class="toc-text">程序返回</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#程序执行过程的跟踪"><span class="toc-number">4.3.</span> <span class="toc-text">程序执行过程的跟踪</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第5章-BX-和loop指令"><span class="toc-number">5.</span> <span class="toc-text">第5章 [BX]和loop指令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#bx"><span class="toc-number">5.1.</span> <span class="toc-text">[bx]</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Loop指令"><span class="toc-number">5.2.</span> <span class="toc-text">Loop指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#在Debug中跟踪用loop指令实现的循环程序"><span class="toc-number">5.3.</span> <span class="toc-text">在Debug中跟踪用loop指令实现的循环程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Debug和汇编编译器masm对指令的不同处理"><span class="toc-number">5.4.</span> <span class="toc-text">Debug和汇编编译器masm对指令的不同处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#loop和-bx-的联合应用"><span class="toc-number">5.5.</span> <span class="toc-text">loop和[bx]的联合应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#段前缀"><span class="toc-number">5.6.</span> <span class="toc-text">段前缀</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一段安全的空间"><span class="toc-number">5.7.</span> <span class="toc-text">一段安全的空间</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第6章-包含多个段的程序"><span class="toc-number">6.</span> <span class="toc-text">第6章 包含多个段的程序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#在代码段中使用数据"><span class="toc-number">6.1.</span> <span class="toc-text">在代码段中使用数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#在代码段中使用栈"><span class="toc-number">6.2.</span> <span class="toc-text">在代码段中使用栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#将数据、代码、栈放入不同的段"><span class="toc-number">6.3.</span> <span class="toc-text">将数据、代码、栈放入不同的段</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第7章-更灵活的定位内存地址的方法"><span class="toc-number">7.</span> <span class="toc-text">第7章 更灵活的定位内存地址的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#and和or指令"><span class="toc-number">7.1.</span> <span class="toc-text">and和or指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#以字符形式给出的数据"><span class="toc-number">7.2.</span> <span class="toc-text">以字符形式给出的数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#大小写转换的问题"><span class="toc-number">7.3.</span> <span class="toc-text">大小写转换的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bx-idata"><span class="toc-number">7.4.</span> <span class="toc-text">[bx+idata]</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#用-bx-idata-的方式进行数组的处理"><span class="toc-number">7.5.</span> <span class="toc-text">用[bx+idata]的方式进行数组的处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SI和DI"><span class="toc-number">7.6.</span> <span class="toc-text">SI和DI</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bx-si-idata-和-bx-di-idata"><span class="toc-number">7.7.</span> <span class="toc-text">[bx+si+idata]和[bx+di+idata]</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不同寻址方式的灵活运用"><span class="toc-number">7.8.</span> <span class="toc-text">不同寻址方式的灵活运用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第8章-数据处理的两个基本问题"><span class="toc-number">8.</span> <span class="toc-text">第8章 数据处理的两个基本问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#bx、si、di和bp"><span class="toc-number">8.1.</span> <span class="toc-text">bx、si、di和bp</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#机器指令处理的数据在什么地方"><span class="toc-number">8.2.</span> <span class="toc-text">机器指令处理的数据在什么地方</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#汇编语言中数据位置的表达"><span class="toc-number">8.3.</span> <span class="toc-text">汇编语言中数据位置的表达</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#立即数（idata）"><span class="toc-number">8.3.1.</span> <span class="toc-text">立即数（idata）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#寄存器"><span class="toc-number">8.3.2.</span> <span class="toc-text">寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#段地址和偏移地址"><span class="toc-number">8.3.3.</span> <span class="toc-text">段地址和偏移地址</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#寻址方式"><span class="toc-number">8.4.</span> <span class="toc-text">寻址方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#指令要处理的数据有多长"><span class="toc-number">8.5.</span> <span class="toc-text">指令要处理的数据有多长</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#div指令"><span class="toc-number">8.6.</span> <span class="toc-text">div指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#伪指令dd"><span class="toc-number">8.7.</span> <span class="toc-text">伪指令dd</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dup"><span class="toc-number">8.8.</span> <span class="toc-text">dup</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第9章-转移指令的原理"><span class="toc-number">9.</span> <span class="toc-text">第9章 转移指令的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#操作符offset"><span class="toc-number">9.1.</span> <span class="toc-text">操作符offset</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jmp指令"><span class="toc-number">9.2.</span> <span class="toc-text">jmp指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#依据位移进行转移的jmp指令"><span class="toc-number">9.3.</span> <span class="toc-text">依据位移进行转移的jmp指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#转移的目的地址在指令中的jmp指令"><span class="toc-number">9.4.</span> <span class="toc-text">转移的目的地址在指令中的jmp指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#转移地址在寄存器中的jmp指令"><span class="toc-number">9.5.</span> <span class="toc-text">转移地址在寄存器中的jmp指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#转移地址在内存中的jmp指令"><span class="toc-number">9.6.</span> <span class="toc-text">转移地址在内存中的jmp指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jcxz指令"><span class="toc-number">9.7.</span> <span class="toc-text">jcxz指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#loop指令"><span class="toc-number">9.8.</span> <span class="toc-text">loop指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#编译器对转移位移超界的检测"><span class="toc-number">9.9.</span> <span class="toc-text">编译器对转移位移超界的检测</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第10章-CALL和RET指令"><span class="toc-number">10.</span> <span class="toc-text">第10章 CALL和RET指令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ret和retf"><span class="toc-number">10.1.</span> <span class="toc-text">ret和retf</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#call指令"><span class="toc-number">10.2.</span> <span class="toc-text">call指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#依据位移进行转移的call指令"><span class="toc-number">10.3.</span> <span class="toc-text">依据位移进行转移的call指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#转移的目的地址在指令中的call指令"><span class="toc-number">10.4.</span> <span class="toc-text">转移的目的地址在指令中的call指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#转移地址在寄存器中的call指令"><span class="toc-number">10.5.</span> <span class="toc-text">转移地址在寄存器中的call指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#转移地址在内存的call指令"><span class="toc-number">10.6.</span> <span class="toc-text">转移地址在内存的call指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#call和ret的配合使用"><span class="toc-number">10.7.</span> <span class="toc-text">call和ret的配合使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mul指令"><span class="toc-number">10.8.</span> <span class="toc-text">mul指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#批量数据的传递"><span class="toc-number">10.9.</span> <span class="toc-text">批量数据的传递</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#寄存器冲突的问题"><span class="toc-number">10.10.</span> <span class="toc-text">寄存器冲突的问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第11章-标志位寄存器"><span class="toc-number">11.</span> <span class="toc-text">第11章 标志位寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ZF标志"><span class="toc-number">11.1.</span> <span class="toc-text">ZF标志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PF标志"><span class="toc-number">11.2.</span> <span class="toc-text">PF标志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SF标志"><span class="toc-number">11.3.</span> <span class="toc-text">SF标志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CF标志"><span class="toc-number">11.4.</span> <span class="toc-text">CF标志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OF标志"><span class="toc-number">11.5.</span> <span class="toc-text">OF标志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#adc指令"><span class="toc-number">11.6.</span> <span class="toc-text">adc指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sbb指令"><span class="toc-number">11.7.</span> <span class="toc-text">sbb指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cmp指令"><span class="toc-number">11.8.</span> <span class="toc-text">cmp指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#检测比较结果的条件转移指令"><span class="toc-number">11.9.</span> <span class="toc-text">检测比较结果的条件转移指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DF标志和串传送指令"><span class="toc-number">11.10.</span> <span class="toc-text">DF标志和串传送指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pushf和popf"><span class="toc-number">11.11.</span> <span class="toc-text">pushf和popf</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第12章-内中断"><span class="toc-number">12.</span> <span class="toc-text">第12章 内中断</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#内中断的产生"><span class="toc-number">12.1.</span> <span class="toc-text">内中断的产生</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#中断处理程序"><span class="toc-number">12.2.</span> <span class="toc-text">中断处理程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#中断向量表"><span class="toc-number">12.3.</span> <span class="toc-text">中断向量表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#中断过程"><span class="toc-number">12.4.</span> <span class="toc-text">中断过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#中断处理程序和iret指令"><span class="toc-number">12.5.</span> <span class="toc-text">中断处理程序和iret指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#单步中断"><span class="toc-number">12.6.</span> <span class="toc-text">单步中断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#响应中断的特殊情况"><span class="toc-number">12.7.</span> <span class="toc-text">响应中断的特殊情况</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第13章-int指令"><span class="toc-number">13.</span> <span class="toc-text">第13章 int指令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#int指令"><span class="toc-number">13.1.</span> <span class="toc-text">int指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BIOS和DOS所提供的中断例程"><span class="toc-number">13.2.</span> <span class="toc-text">BIOS和DOS所提供的中断例程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BIOS和DOS中断例程的安装过程"><span class="toc-number">13.3.</span> <span class="toc-text">BIOS和DOS中断例程的安装过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BIOS中断例程应用"><span class="toc-number">13.4.</span> <span class="toc-text">BIOS中断例程应用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第14章-端口"><span class="toc-number">14.</span> <span class="toc-text">第14章 端口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#端口的读写"><span class="toc-number">14.1.</span> <span class="toc-text">端口的读写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CMOS-RAM芯片"><span class="toc-number">14.2.</span> <span class="toc-text">CMOS RAM芯片</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#shl和shr指令"><span class="toc-number">14.3.</span> <span class="toc-text">shl和shr指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CMOS-RAM中存储的时间信息"><span class="toc-number">14.4.</span> <span class="toc-text">CMOS RAM中存储的时间信息</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第15章-外中断"><span class="toc-number">15.</span> <span class="toc-text">第15章 外中断</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#接口芯片和端口"><span class="toc-number">15.1.</span> <span class="toc-text">接口芯片和端口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#外中断信息"><span class="toc-number">15.2.</span> <span class="toc-text">外中断信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PC机键盘的处理过程"><span class="toc-number">15.3.</span> <span class="toc-text">PC机键盘的处理过程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第16章-直接定址表"><span class="toc-number">16.</span> <span class="toc-text">第16章 直接定址表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#描述了单元长度的标号"><span class="toc-number">16.1.</span> <span class="toc-text">描述了单元长度的标号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#在其他段中使用数据标号"><span class="toc-number">16.2.</span> <span class="toc-text">在其他段中使用数据标号</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第17章-使用BIOS进行键盘输入和磁盘读写"><span class="toc-number">17.</span> <span class="toc-text">第17章 使用BIOS进行键盘输入和磁盘读写</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#应用int-13h中断例程对磁盘进行读写"><span class="toc-number">17.1.</span> <span class="toc-text">应用int 13h中断例程对磁盘进行读写</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/pic.jpg"></div><div class="author-info-name">l34rner</div><div class="author-info-description"></div><div class="links-buttons"><a class="links-button button-hover" href="https://github.com/l34rner" target="_blank">GitHub<i class="icon-dot bg-color7"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="/archives"><span class="pull-top">日志</span><span class="pull-bottom">1</span></a><a class="author-info-articles-tags article-meta" href="/tags"><span class="pull-top">标签</span><span class="pull-bottom">1</span></a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/">首页</a><a class="menu-item" href="/tags">标签</a><a class="menu-item" href="/categories">分类</a><a class="menu-item" href="/archives">归档</a><a class="menu-item" href="/about">关于</a></nav><div class="right-info"><a class="title-name" href="/">一个记录自己学习轨迹的自娱自乐之地</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><article id="post"><div class="post-header"><div class="title">王爽汇编语言笔记</div><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 发表于 2018-07-08 | 更新于 2019-12-02</time><!--time.button-hover.post-date #[i.fas.fa-calendar-alt.article-icon(aria-hidden="true")] #[=__('post.modified')] #[=date(page['updated'], config.date_format)]--><div class="button-hover categories"></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AF%87%C2%B7%E5%8C%96%E6%97%A0%E7%82%BC%E6%9C%89/">学习篇·化无炼有</a></div></div></div><div class="main-content"><h1 id="第1章-基础知识"><a href="#第1章-基础知识" class="headerlink" title="第1章 基础知识"></a>第1章 基础知识</h1><h2 id="机器语言"><a href="#机器语言" class="headerlink" title="机器语言"></a>机器语言</h2><p>机器语言是机器指令的集合，电子计算机的机器指令是一列二进制数字，计算机将这列二进制数转化为一列高低电平从而驱动计算机的电子器件进行运算。<br>CPU是一种微处理器，通常我们讲的计算机是指由CPU和其他受CPU控制的芯片，器件，设备组成的计算机系统。<br>每一种微处理器，由于硬件设计和内部结构的不同，就需要用不同的电平脉冲来控制使其工作，所以每一种微处理器都有自己的机器指令集，也就是机器语言。</p>
<h2 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h2><p>汇编语言发展至今，包含3类指令。<br>汇编指令：汇编语言的主体是汇编指令，汇编指令是机器指令便于记忆的格式，与机器指令是一一对应的。<br>伪指令：没有对应的机器码，由编译器执行，计算机并不执行。<br>其他符号：由编译器识别，没有对应的机器码。</p>
<h2 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h2><p>要想让一个CPU工作，就必须向它提供指令和数据，这些指令和数据要在存储器中存放，也就是通常所说的内存。磁盘不同于内存，磁盘中的程序或数据如果不读到内存中，就无法被CPU使用。</p>
<h2 id="指令和数据"><a href="#指令和数据" class="headerlink" title="指令和数据"></a>指令和数据</h2><p>在内存和磁盘上，指令和数据没有任何区别，都是二进制信息，CPU在工作时把有的信息看作指令，有的信息看作数据，为同样的信息赋予了不同的含义。</p>
<h2 id="存储单元"><a href="#存储单元" class="headerlink" title="存储单元"></a>存储单元</h2><p>内存被划分为若干个存储单元，每个存储单元存放一个字节（byte），存储单元从0开始顺序编号。</p>
<h2 id="CPU对存储器的读写"><a href="#CPU对存储器的读写" class="headerlink" title="CPU对存储器的读写"></a>CPU对存储器的读写</h2><p>在一台计算机中，不只有存储器这一种器件，CPU在读写数据时必须指明，它要对哪一个器件进行操作，进行何种操作，是从中读出数据，还是往里写入数据。<br>CPU要想进行数据的读写，必须和外部器件（标准说法是芯片）进行3类信息的交互。<br>地址信息：要操作的存储单元的地址<br>控制信息：器件的选择，读或写的命令<br>数据信息：读或写的数据<br>在计算机中有专门连接CPU和其他芯片的导线，称为总线。总线从物理上来讲就是一根根导线的集合，从逻辑上（即根据作用的不同）分成：地址总线，数据总线和控制总线。</p>
<h2 id="地址总线"><a href="#地址总线" class="headerlink" title="地址总线"></a>地址总线</h2><p>CPU是通过地址总线来指定存储单元的，可见地址总线上能传送多少个不同的信息，CPU就可以对多少个存储单元进行寻址。<br>在计算机中，一根导线可以传送的稳定状态只有两种，高电平和低电平，用二进制表示就是1和0。那么，10根导线能传送10位二进制数，10位的二进制数能表示2^10个数据。<br>一个CPU有N根地址线，那么就说这个CPU的地址总线宽度为N，这样的CPU最多能寻址2^N个内存单元。</p>
<p><img src="/2018/07/08/%E7%8E%8B%E7%88%BD%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/10-55-25.jpg" alt></p>
<h2 id="数据总线"><a href="#数据总线" class="headerlink" title="数据总线"></a>数据总线</h2><p>CPU与内存或其他器件之间的数据传送是通过数据总线进行的，数据总线的宽度决定了CPU和外界数据传送的速度。8086CPU的数据总线宽度为16，即一次最多能传送两个字节。</p>
<h2 id="控制总线"><a href="#控制总线" class="headerlink" title="控制总线"></a>控制总线</h2><p>CPU对外部器件的控制是通过控制总线进行的。控制总线是一些不同控制线的集合，控制总线的宽度决定了CPU对外部器件的控制能力。</p>
<h2 id="内存地址空间"><a href="#内存地址空间" class="headerlink" title="内存地址空间"></a>内存地址空间</h2><p>CPU可寻址的所有内存单元构成了CPU的内存地址空间。</p>
<p><img src="/2018/07/08/%E7%8E%8B%E7%88%BD%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/11-00-40.jpg" alt></p>
<h2 id="接口卡"><a href="#接口卡" class="headerlink" title="接口卡"></a>接口卡</h2><p>所有可用程序控制的设备，都必须受到CPU的控制，CPU不是直接控制它们，而是通过接口卡控制这些设备。<br>CPU通过总线发送命令给接口卡，接口卡根据CPU的命令控制外设进行工作。</p>
<p><img src="/2018/07/08/%E7%8E%8B%E7%88%BD%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/11-05-30.jpg" alt></p>
<h2 id="各类存储器芯片"><a href="#各类存储器芯片" class="headerlink" title="各类存储器芯片"></a>各类存储器芯片</h2><p>一台计算机中有多个存储器芯片，这些存储器芯片从物理连接上来看是独立的，从读写属性上来看分为两类：随机存储器（RAM）和只读存储器（ROM）。随机存储器可读可写，但必须带电存储，关机后存储的内容就会丢失；只读存储器只能读取不能写入，关机后其中的内容不会丢失。</p>
<h1 id="第2章-寄存器"><a href="#第2章-寄存器" class="headerlink" title="第2章 寄存器"></a>第2章 寄存器</h1><p>一个典型的CPU由运算器，控制器，寄存器等器件组成，这些器件由内部总线相连。内部总线实现CPU内部器件之间的联系，外部总线实现CPU和主板上其他器件的联系。<br>运算器：进行信息处理<br>控制器：控制各器件工作<br>寄存器：进行信息存储<br>寄存器是CPU中程序员可以用指令读写的部件。8086CPU有14个寄存器：AX,BX,CX,DX,SI,DI,SP,BP,IP,CS,DS,ES,SS,PSW</p>
<h2 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h2><p>8086CPU是16位的，可以用来存放两个字节。AX,BX,CX,DX用来存放一般性数据，被称为通用寄存器，并且这4个寄存器每个都可以分为两个独立的8位寄存器来用<br>AX分为AH和AL<br>BX分为BH和BL<br>CX分为CX和CL<br>DX分为DH和DL<br>H是高8位，L是低8位<br><img src="/2018/07/08/%E7%8E%8B%E7%88%BD%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/19-45-23.jpg" alt></p>
<h2 id="字在寄存器中的存储"><a href="#字在寄存器中的存储" class="headerlink" title="字在寄存器中的存储"></a>字在寄存器中的存储</h2><p>8086CPU一次性可以处理两种尺寸的数据：<br>字节：记为byte，一个字节由8个bit组成，可以存在8位寄存器中<br>字：记为word，一个字由两个字节组成，这两个字节分别称为这个字的高位字节和低位字节<br><img src="/2018/07/08/%E7%8E%8B%E7%88%BD%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/19-48-27.jpg" alt></p>
<p>一位16进制的数相当于4位二进制数，所以0100111000100000可以表示为4（0100）E（1110）2（0010）0（0000），从低位往高位每4位进行一个划分，最后剩余不足4位的补0即可。</p>
<h2 id="几条汇编指令"><a href="#几条汇编指令" class="headerlink" title="几条汇编指令"></a>几条汇编指令</h2><p>汇编指令不区分大小写<br><img src="/2018/07/08/%E7%8E%8B%E7%88%BD%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/19-51-03.jpg" alt><br>如果有这么一个数1044CH要存放在寄存器中，首先从低位开始存，存满16位后，由于这个数是20位的，最高位的1是存不进去的，所以最终在寄存器中存下的数是044CH。<br>在进行数据的传送或运算时，要注意指令的两个操作数的位数必须一致，即要么都是8位，要么都是16位。</p>
<h2 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h2><p>CPU访问内存单元时，要给出内存单元的地址，所有的内存单元构成一个一维线性存储空间，每个内存单元在这个空间中都有唯一的地址，称为物理地址。CPU通过总线传入存储器的，必须是一个物理地址。</p>
<h2 id="16位的CPU结构"><a href="#16位的CPU结构" class="headerlink" title="16位的CPU结构"></a>16位的CPU结构</h2><p>16位结构的含义：<br>运算器一次最多能处理16位数据<br>寄存器最大宽度是16位<br>寄存器和运算器之间的通路是16位</p>
<h2 id="8086CPU给出物理地址的方法"><a href="#8086CPU给出物理地址的方法" class="headerlink" title="8086CPU给出物理地址的方法"></a>8086CPU给出物理地址的方法</h2><p>由于CPU与外部器件的链接有20位地址线，可传送20位的地址而CPU本身又是16位结构，所以：物理地址=段地址*16+偏移地址</p>
<h2 id="段地址-16-偏移地址-物理地址的本质含义"><a href="#段地址-16-偏移地址-物理地址的本质含义" class="headerlink" title="段地址*16+偏移地址=物理地址的本质含义"></a>段地址*16+偏移地址=物理地址的本质含义</h2><p>物理地址=段地址*16+偏移地址 的本质含义是：用一个基础地址，和一个相对于基础地址的偏移地址相加，得到最终物理地址。</p>
<h2 id="段的概念"><a href="#段的概念" class="headerlink" title="段的概念"></a>段的概念</h2><p>段是逻辑上的概念，内存并没有被物理分成一段一段的。编程时可根据需要将任意地址连续的内存单元看做一个段，用段地址*16定位这个段的起始地址，用偏移地址定位这个段中的内存单元。所以段的起始地址一定是16的倍数，偏移地址是16位，可寻址64KB，所以一个段的最大长度是64KB。</p>
<h2 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h2><p>段地址在段寄存器中存放，8086CPU有4个段寄存器：CS,DS,ES,SS。s:segment</p>
<h2 id="CS和IP"><a href="#CS和IP" class="headerlink" title="CS和IP"></a>CS和IP</h2><p>CS：代码段寄存器<br>IP：指令指针寄存器<br>CS和IP指示了当前CPU要读取的指令的地址，即任意时刻，CPU将CS:IP指向的内容当做指令执行。每读取一条指令后，IP的值自动增加，读取的指令长度是N字节，IP就增加N。<br>整个过程如下：<br>读取指令。从CS:IP指向的内存单元读取指令，读取的指令进入指令缓冲器<br>IP自增。IP=IP+读取指令的长度，从而指向下一条指令<br>执行指令。<br>CPU刚开始工作时，CS=FFFFH，IP=0000H，所以8086机器刚启动时，FFFF0H单元中的内容是开机后执行的第一条指令。</p>
<h2 id="修改CS、IP的指令"><a href="#修改CS、IP的指令" class="headerlink" title="修改CS、IP的指令"></a>修改CS、IP的指令</h2><p>8086CPU中大部分寄存器的值，都可以用MOV指令来修改，MOV指令被称为传送指令。但是mov指令不能用来设置CS，IP的值。<br>能够改变CS，IP的指令被称为转移指令，最常见的jmp指令<br>同时修改CS,IP的值，用：jmp 段地址：偏移地址，指令中给出的段地址就会存入CS，偏移地址存入IP<br>只想修改IP，用：jmp 某一合法寄存器</p>
<h2 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h2><p>CPU只认CS:IP指向的内容为指令，所以如果要让CPU执行我们放在代码段中的指令，就必须让CS:IP指向代码段中第一条指令的地址。</p>
<h1 id="第3章-寄存器（内存访问）"><a href="#第3章-寄存器（内存访问）" class="headerlink" title="第3章 寄存器（内存访问）"></a>第3章 寄存器（内存访问）</h1><h2 id="内存中字的存储"><a href="#内存中字的存储" class="headerlink" title="内存中字的存储"></a>内存中字的存储</h2><p>CPU中，用16位寄存器来存放一个字。高8位存放高位字节，低8位存放低位字节。由于内存单元是字节单元（即一个单元存放一个字节）所以一个字要用两个地址连续的内存单元存放，这个字的低位字节存放在低地址单元中，高位字节存放在高地址单元中。<br>字单元：存放一个字型数据的内存单元，由两个地址连续的内存单元组成，高地址内存单元存放高位字节，低地址内存单元存放低位字节。<br>起始地址为N的字单元简称N地址字单元，注意起始地址是低地址。</p>
<h2 id="DS和-address"><a href="#DS和-address" class="headerlink" title="DS和[address]"></a>DS和[address]</h2><p>DS：数据段寄存器，存放数据的段地址。<br>[N]表示一个偏移地址为N的内存单元。<br>MOV指令可以将内存单元中的数据送入寄存器，格式为：mov 寄存器名,内存单元。指令执行时，CPU自动取ds中的数据作为内存单元的段地址。如mov bx,[0]实际上是将ds:0处的内容送入bx。<br>8086CPU不支持将数据直接送入段寄存器，必须用一个通用寄存器来中转：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">mov bx,1000H </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">mov ds,bx</span></pre></td></tr></table></figure>
<h2 id="字的传送"><a href="#字的传送" class="headerlink" title="字的传送"></a>字的传送</h2><p>由于8086CPU有16根数据线，所以一次可以传送16位数据，只要在MOV指令中给出16位的寄存器就可以进行16位数据的传送了。<br>即：给出的是16位寄存器，就传送16位数据，给出8位寄存器，就传送8位数据。</p>
<h2 id="mov、add、sub指令"><a href="#mov、add、sub指令" class="headerlink" title="mov、add、sub指令"></a>mov、add、sub指令</h2><p>mov指令有以下几种形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">mov 寄存器,数据</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">mov 寄存器,寄存器</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">mov 寄存器,内存单元</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">mov 内存单元,寄存器</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">mov 段寄存器，寄存器</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">mov 寄存器，段寄存器</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">mov 内存单元,段寄存器</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">mov 段寄存器,内存单元</span></pre></td></tr></table></figure>
<h2 id="数据段"><a href="#数据段" class="headerlink" title="数据段"></a>数据段</h2><p>我们可以将一组起始地址为16的倍数，地址连续，长度不超过64K的内存单元当做一个段来使用。具体作为什么段，取决于段地址存放在哪个段寄存器中，如果存放在ds中，那么这个段就被当做数据段，用于存放数据。</p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈是一种具有特殊访问方式的存储空间，其特殊性在于数据的访问方式都是后进先出。<br>栈有两个基本操作：入栈和出栈。入栈是将一个新的元素放到栈顶，出栈就是从栈顶取出一个元素。栈顶元素总是最后入栈，最先出栈。</p>
<h2 id="CPU提供的栈机制"><a href="#CPU提供的栈机制" class="headerlink" title="CPU提供的栈机制"></a>CPU提供的栈机制</h2><p>8086CPU两个最基本的栈操作指令是PUSH和POP。push ax：将ax中的数据送入栈中，pop ax：将栈顶数据取出放入ax。8086CPU的入栈和出栈操作都是以字为单位进行的。<br>入栈时，栈顶从高地址移向低地址；出栈时，栈顶从低地址移向高地址。<br>栈顶的段地址存放在SS中，偏移地址存放在SP中，任意时刻SS:SP指向栈顶元素的低地址。<br>push ax的执行分为两步：<br>1.SP=SP-2<br>2.将ax中的内容送入SS:SP指向的内存单元处，此时SS:SP指向新的栈顶<br>pop ax的执行分为两步：<br>1.将SS:SP指向的内存单元的数据送入ax<br>2.SP=SP+2<br>栈为空，就相当于栈中唯一的元素出栈，出栈后SP+2，所以栈空时，SS:SP指向栈空间最高地址单元的下一个单元，入栈后SS:SP指向栈顶第一个元素。<br>出栈后，SS:SP指向新的栈顶，POP操作前的栈顶元素依然存在于内存中，但此时它已不在栈中，当再次执行PUSH指令后，该处内存将被新的数据覆盖。</p>
<h2 id="栈顶超界的问题"><a href="#栈顶超界的问题" class="headerlink" title="栈顶超界的问题"></a>栈顶超界的问题</h2><p>当栈满的时候入栈，或者栈空的时候出栈，都将发生栈顶越界的问题，而8086CPU只知道栈顶在何处，不知道我们安排的栈空间有多大，所以CPU是不能保证我们对栈的操作不发生越界的。<br>也就是说：CPU只记录栈顶，栈空间的大小需要我们自己管理。</p>
<h2 id="push、pop指令"><a href="#push、pop指令" class="headerlink" title="push、pop指令"></a>push、pop指令</h2><p>栈空间也是内存空间的一部分，它只是一段可以用特殊方式进行访问的内存空间。<br>push的指令格式有以下几种：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">push 寄存器</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">push 段寄存器</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">push 内存单元</span></pre></td></tr></table></figure>
<p>pop指令与push指令格式相同<br>可以在push和pop指令中只给出内存单元的偏移地址，cpu会自动从ds中获取段地址。<br>push、pop实质上就是一种内存传送指令，可以在寄存器和内存之间传送数据，与mov指令不同的是，push和pop访问的内存单元地址不是在指令中给出的，而是由SS:SP指定的，同时push和pop在执行时还要改变sp中的内容。<br>CPU执行mov时，只有一步操作，就是传送，执行栈操作时，需要两步操作，其中多出的一步是修改SP。<br>push，pop等栈操作指令，修改的只是SP，也就是说栈的变化范围最大为0~FFFFH。</p>
<h2 id="栈段"><a href="#栈段" class="headerlink" title="栈段"></a>栈段</h2><p>我们可以将起始地址为16的倍数，长度不超过64KB的地址连续的内存单元当做栈空间来用。<br>我们可以将一段内存定义为一个段，用一个段地址指示段，用偏移地址访问段内的单元，这完全是我们自己的安排。我们可以用一个段存放数据，将它定义为数据段，也可以用一个段存放代码，将它定义为代码段，也可以将一个段作为栈来用，定义为栈段。这样安排是可以的，但是要让CPU按照我们的安排来使用这些段，就要对于数据段，要将它的段地址放入ds，对于代码段，要将它的段地址放入CS，对于栈段，要将它的段地址放入SS。CPU将内存中的某段内存当做代码，是因为CS:IP指向了那里，将某段内存当做栈，是因为SS:SP指向了那里，所以一定要清楚，什么是我们的安排，以及如何让CPU按我们的安排行事。</p>
<h1 id="第4章-第一个程序"><a href="#第4章-第一个程序" class="headerlink" title="第4章 第一个程序"></a>第4章 第一个程序</h1><h2 id="一个源程序从写出到执行的过程"><a href="#一个源程序从写出到执行的过程" class="headerlink" title="一个源程序从写出到执行的过程"></a>一个源程序从写出到执行的过程</h2><p>第一步：编写汇编源程序<br>第二步：对源程序进行编译连接。编译程序对源程序文件中的源程序进行编译，产生目标文件；再用连接程序对目标文件进行连接，生成可执行文件。可执行文件包含两部分：程序和数据；相关的描述信息<br>第三部：执行。操作系统按照可执行文件中的描述信息，将可执行文件中的程序和数据载入内存，进行相关的初始化后由CPU开始执行。</p>
<h2 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h2><h3 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令"></a>伪指令</h3><p>汇编语言源程序中包含两种指令，一种是汇编指令，一种是伪指令。汇编指令有对应的机器码，可以被编译为机器指令，最终由CPU执行，伪指令没有对应的机器码，由编译器执行，编译器根据伪指令来进行相关的编译工作。<br>源程序的框架</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;*</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">告诉编译器将某个段寄存器与程序中定义的段相关联，这样定义后段名就代表了一个段地址，但这还不够，在后面的指令中依然要将段地址送入对应的段寄存器中</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">*&#x2F; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">assume 段寄存器:段名 </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">段名 segment</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">段名 ends   &#x2F;&#x2F;ends表示end segment，即一个段结束</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">end</span></pre></td></tr></table></figure>
<p>segment和ends是成对使用的伪指令，这是在编写汇编程序时必须用到的一对伪指令。segment和ends的功能是定义一个段，segment表示段开始，ends表示段结束，一个段必须要有一个名称来标识。<br>一个汇编程序由多个段组成，这些段被用来存放代码，数据或被当做栈空间使用，一个源程序中所有将被计算机处理的信息：指令，数据，栈，被划分到了不同的段中。<br>一个有意义的汇编程序中至少要有一个段，就是代码段。</p>
<h3 id="end"><a href="#end" class="headerlink" title="end"></a>end</h3><p>end是汇编程序的结束标记，编译器如果碰到了end指令，就结束对源程序的编译。<br>end 标号，CPU会将这个标号作为程序的入口地址。</p>
<h3 id="assume"><a href="#assume" class="headerlink" title="assume"></a>assume</h3><p>编程时，记住用assume将有特定用途的段和相关的寄存器关联起来即可。<br>源程序文件中的所有内容称为源程序，源程序中最终由计算机处理的指令和数据称为程序。</p>
<h3 id="标号"><a href="#标号" class="headerlink" title="标号"></a>标号</h3><p>汇编源程序中除了汇编指令和伪指令外，还有一些标号，这些标号表示一个地址。</p>
<h3 id="程序返回"><a href="#程序返回" class="headerlink" title="程序返回"></a>程序返回</h3><p>一个程序A要想运行，必须有一个正在运行的程序B将A载入内存，将CPU的控制权交给A，A才能运行。A开始运行后，B就暂停运行了。当A运行完毕，应将CPU的控制权交还给B，然后B继续运行。<br>一个程序运行结束后，将CPU的控制权交还给使它得以运行的程序，这个过程称为程序返回。<br>程序返回指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">mov ax,4c00H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">int 21H</span></pre></td></tr></table></figure>
<h2 id="程序执行过程的跟踪"><a href="#程序执行过程的跟踪" class="headerlink" title="程序执行过程的跟踪"></a>程序执行过程的跟踪</h2><p>在DOS中运行一个程序时，是由command将程序载入内存并使其运行。<br>Debug可以将程序载入内存但并不放弃对CPU的控制。<br>Debug将程序载入内存后，cx中存放的就是程序的长度，以字节为单位。<br>在DOS中程序的加载过程如下：<br>1.找到一段起始地址的偏移地址为0且容量足够的空闲内存区<br>2.在这段内存的前256个字节创建一个称为程序段前缀PSP的数据区，DOS利用PSP和被加载的程序进行通信<br>3.在PSP的后面将程序装入，为了更好地区分PSP和程序，DOS一般将它们划分到不同的段中，虽然它们的物理地址是连续的但却有不同的段地址，所以如果PSP的地址为SA:0，那么程序的地址就是SA+10H:0</p>
<h1 id="第5章-BX-和loop指令"><a href="#第5章-BX-和loop指令" class="headerlink" title="第5章 [BX]和loop指令"></a>第5章 [BX]和loop指令</h1><p>在debug中写汇编指令时，可以用[n]来表示一个偏移地址为n的内存单元，但是在汇编源程序中[n]会被认为是数字n，要使编译器将其当做一个偏移地址，就必须先将n送入bx，再使用[bx]的方式，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">mov bx,0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">mov ax,[bx]</span></pre></td></tr></table></figure>
<p>要完整地描述一个内存单元，需要两种信息：内存单元的地址；内存单元的长度（字单元还是字节单元）<br>内存单元的长度可以由具体指令中的其他操作对象（如寄存器）指出。<br>mov ax,[bx]表示将一个内存单元的内容送入ax，这个内存单元长度为两个字节，段地址在DS中，偏移地址在bx中。<br>用()表示一个寄存器或内存单元的内容，如：(ax)表示ax中的内容<br>符号idata表示常量。</p>
<h2 id="bx"><a href="#bx" class="headerlink" title="[bx]"></a>[bx]</h2><p>[bx]表示的是一个内存单元，这个内存单元的偏移地址是bx中的值，段地址在ds中。<br>inc bx表示bx的内容加1</p>
<h2 id="Loop指令"><a href="#Loop指令" class="headerlink" title="Loop指令"></a>Loop指令</h2><p>loop指令的格式是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">loop 标号</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">标号：语句</span></pre></td></tr></table></figure>
<p>CPU执行loop指令时，进行两步操作<br>1.(cx)=(cx)-1<br>2.判断cx中的值，不为零则跳转到标号处执行，否则向下执行<br>通常我们用loop指令来实现循环，cx中存放循环的次数，要循环执行的程序段，需写在标号和loop指令之间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">#循环程序框架</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">mov cx,循环次数</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">s:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">循环执行的程序段</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">loop s</span></pre></td></tr></table></figure>
<p>写汇编代码时，16进制数据后的H不能省，否则编译器会默认为10进制数，而在debug中，数据默认是16进制的。</p>
<h2 id="在Debug中跟踪用loop指令实现的循环程序"><a href="#在Debug中跟踪用loop指令实现的循环程序" class="headerlink" title="在Debug中跟踪用loop指令实现的循环程序"></a>在Debug中跟踪用loop指令实现的循环程序</h2><p>汇编源程序中，数据不能以字母开头，如果一个数据以字母开头，需要在前面加一个0。如果要将FFFFH送入AX中，为mov ax,0FFFFH</p>
<h2 id="Debug和汇编编译器masm对指令的不同处理"><a href="#Debug和汇编编译器masm对指令的不同处理" class="headerlink" title="Debug和汇编编译器masm对指令的不同处理"></a>Debug和汇编编译器masm对指令的不同处理</h2><p>在debug中[n]被当做一个内存单元，而在汇编源程序中[n]被当做数字n，要想在汇编源程序中将[n]当做内存单元，就需要显示给出段地址，如mov ax,ds:[0]</p>
<h2 id="loop和-bx-的联合应用"><a href="#loop和-bx-的联合应用" class="headerlink" title="loop和[bx]的联合应用"></a>loop和[bx]的联合应用</h2><p>考虑一个问题：计算ffff:0<del>ffff:b中数据的和，结果存储在dx中。<br>首先需要分析一下，运算后的结果是否会超出dx所能存储的范围？由于ffff:0</del>ffff:b中都是字节型数据，范围在0~255,12个这样的数据相加不会超过65535，所以结果可以存在dx中。<br>那么能否将这些数据直接加到dx中？<br>不行，因为这些都是字节单元，也就是8位数据，不能直接加到16位寄存器中。<br>那么能否将这些数据累加到dl中，并设置dh=0，从而实现累加到dx中？<br>也不行，dl是8位寄存器，12个字节型数据相加会超过255，所以不能存到dl中。<br>首先需要明白一个赋值的概念，所谓赋值，就是让两个对象的值相等，也就是说虽然一个16位寄存器和一个字节型内存单元的长度不一样，但是完全可以做到寄存器中存放的值和字节型内存单元中存放的值相等。这里累加12个内存单元的值并存放到dx中，也是用一个16位寄存器做中介，将内存单元中的8位数据赋值到一个16寄存器中，再将这个寄存器中的值累加到dx上即可。</p>
<h2 id="段前缀"><a href="#段前缀" class="headerlink" title="段前缀"></a>段前缀</h2><p>段地址只能存放在段寄存器中。<br>我们可以在访问内存单元的指令中显示地给出内存单元段地址所在的段寄存器，而用于显示指明内存单元段地址的cs,ds,es,ss统称为段前缀。</p>
<h2 id="一段安全的空间"><a href="#一段安全的空间" class="headerlink" title="一段安全的空间"></a>一段安全的空间</h2><p>在8086模式中，随意向一段内存空间写入内容是很危险的，因为这段空间中可能存放着重要的系统数据或代码。<br>在实模式（纯DOS模式）下，可以不理会DOS，直接用汇编语言去操作真实的硬件，因为运行在CPU实模式下的DOS没有能力对硬件系统进行全面严格的管理，但在windows2000,unix这些运行在CPU保护模式下的操作系统中，不理会操作系统，直接用汇编语言操作硬件是根本不可能的。<br>DOS和其他合法程序一般不会使用0:200~0:2ff这段空间，所以这段空间可以为我们所用。</p>
<h1 id="第6章-包含多个段的程序"><a href="#第6章-包含多个段的程序" class="headerlink" title="第6章 包含多个段的程序"></a>第6章 包含多个段的程序</h1><p>在操作系统环境中，合法地通过操作系统取得的空间都是安全的，因为操作系统不会让一个程序所用的空间和其他程序以及系统自己的空间相冲突，在操作系统允许的情况下，程序可以取得任意容量的空间。<br>程序取得所需空间的方法有两种，一是在加载程序的时候为程序分配，二是程序在执行的过程中向系统申请。<br>若要一个程序在被加载的时候取得所需的空间，则必须在源程序中做出说明，我们通过在源程序中定义段来进行内存空间的获取。<br>大多数有用的程序，都要处理数据，使用栈空间，也都有指令，为了程序设计的清晰和方便，我们一般也都定义不同的段来存放他们。</p>
<h2 id="在代码段中使用数据"><a href="#在代码段中使用数据" class="headerlink" title="在代码段中使用数据"></a>在代码段中使用数据</h2><p>考虑这样一个问题，将指定的若干数据相加，结果存在ax寄存器中：0123H,0456H,0789H,0abcH,0defH,0fedH,0cbaH,0987H。如果要用循环的方法来累加，就要将这些数据存储在一组地址连续的内存单元中，那么就要先找到这样一组地址连续的内存单元。<br>但是，我们是不能自己随便决定哪段空间可以使用的，应该让系统为我们分配，我们可以在程序中定义我们希望处理的数据，这些数据就会被编译，链接，作为程序的一部分写到可执行文件中。当可执行文件被加载到内存中时，这些数据也同样被加载到内存，我们要处理的数据也就自然而然获得了存储空间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">assume cs:code</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">code segment</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">#这8个数据存在了代码段的开头，所以这些数据的地址就是CS:0,CS:2,CS:4,...CS:E</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">dw 0123H,0456H,0789H,0abcH,0defH,0fedH,0cbaH,0987H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">......</span></pre></td></tr></table></figure>
<p>dw表示定义字型数据，即define word，这里使用dw定义了8个字型数据，数据之间以逗号分隔。<br>可执行文件由描述信息和程序组成，程序来自源程序中的汇编指令和定义的数据，描述信息则是由编译链接程序对源程序中的伪指令进行处理所得到的信息，程序被加载到内存后，加载者从描述信息中得到程序的入口地址，设置CS:IP，然后CPU就从我们希望的地址处开始执行。</p>
<h2 id="在代码段中使用栈"><a href="#在代码段中使用栈" class="headerlink" title="在代码段中使用栈"></a>在代码段中使用栈</h2><p>假设代码段中存放了8个字型数据，现在需要将它们逆序存放</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">assume cs:codeseg</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">codeseg segment</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">dw 0123H,0456H,0789H,0abcH,0defH,0fedH,0cbaH,0987H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">?</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">codeseg ends</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">end</span></pre></td></tr></table></figure>
<p>要逆序存放这8个字型数据，可以使用栈，先将这8个数据入栈，然后出栈，从而实现数据的逆序存放。但是，我们首先要有一段可以当做栈来用的内存空间，这段空间应该由系统来分配。所以我们可以通过在程序中定义数据来取得一段空间，然后将这段空间当做栈来使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">assume cs:codeseg</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">codeseg segment</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">dw 0123H,0456H,0789H,0abcH,0defH,0fedH,0cbaH,0987H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">#用dw定义16个字型数据，程序加载后会取得这16个字的内存空间，在后面的程序中将这段空间当做栈来使用</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">......</span></pre></td></tr></table></figure>
<h2 id="将数据、代码、栈放入不同的段"><a href="#将数据、代码、栈放入不同的段" class="headerlink" title="将数据、代码、栈放入不同的段"></a>将数据、代码、栈放入不同的段</h2><p>将数据，代码和栈放到同一个段中，一来显得混乱，二来如果数据，代码和栈需要的空间超出64K，那么一个段内就放不下，所以应该考虑用多个段来分别存放代码，数据和栈。<br>定义多个段的方法和定义一个段并没有区别，只是对于不同的段，需要不同的段名。程序中，段名相当于一个标号，代表了段地址，mov ax,xyz的含义就是将名为xyz的段的段地址送入ax中，一个段中的数据的段地址可以由段名来代表。同时，不能直接mov ds,xyz，因为8086CPU不允许直接将数值送入段寄存器，程序在编译时，段名会被编译器处理为一个表示段地址的数值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data,ss:stack</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">data segment</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">dw 0123H,0456H,0789H,0abcH,0defH,0fedH,0cbaH,0987H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">data ends</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">stack segment</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">stack ends</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">code segment</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">......</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">code ends</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">end start</span></pre></td></tr></table></figure>
<h1 id="第7章-更灵活的定位内存地址的方法"><a href="#第7章-更灵活的定位内存地址的方法" class="headerlink" title="第7章 更灵活的定位内存地址的方法"></a>第7章 更灵活的定位内存地址的方法</h1><h2 id="and和or指令"><a href="#and和or指令" class="headerlink" title="and和or指令"></a>and和or指令</h2><p>and指令：按位进行与运算，可以将操作对象的特定位设置为0，其他位不变<br>or指令：按位进行或运算，可以将操作对象的特定位设置为1，其他位不变</p>
<h2 id="以字符形式给出的数据"><a href="#以字符形式给出的数据" class="headerlink" title="以字符形式给出的数据"></a>以字符形式给出的数据</h2><p>我们可以在汇编程序中用<code>&#39;...&#39;</code>的方式指明数据是以字符形式给出的，编译器会把它们转换成对应的ASCII码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">assume ds:data</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">data segment</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">db &#39;unIX&#39;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">data ends</span></pre></td></tr></table></figure>
<p>db表示定义字节型数据，<code>db &#39;unIX&#39;</code>相当于<code>db 75H,6eH,49H,58H</code>,分别是u,n,I,X的ASCII码。</p>
<h2 id="大小写转换的问题"><a href="#大小写转换的问题" class="headerlink" title="大小写转换的问题"></a>大小写转换的问题</h2><p>要改变一个字母的大小写，实际上就是改变它的ASCII码，从ASCII码的二进制形式来看，大写字母和小写字母除了第5位不同，其他各位都一样，大写字母第5位是0，小写字母第5位是1。</p>
<h2 id="bx-idata"><a href="#bx-idata" class="headerlink" title="[bx+idata]"></a>[bx+idata]</h2><p>[bx+idata]表示一个偏移地址为(bx)+idata的内存单元，也可以写成idata[bx]或[bx].idata<br>mov ax,[bx+200]表示将ds:(bx)+200处的内容送入ax。</p>
<h2 id="用-bx-idata-的方式进行数组的处理"><a href="#用-bx-idata-的方式进行数组的处理" class="headerlink" title="用[bx+idata]的方式进行数组的处理"></a>用[bx+idata]的方式进行数组的处理</h2><p>考虑如下问题，将datasg中第一个字符串全部转为大写，第二个字符串全部转为小写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">assume ds:datasg</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">datasg segment</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">db &#39;BaSiC&#39;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">db &#39;MinIX&#39;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">......</span></pre></td></tr></table></figure>
<p>datasg中的两个字符串，一个起始地址为0，一个起始地址为5，那么可以用[0+bx]和[5+bx]的方式在同一循环中定位这两个字符串中的字符，然后分别进行大小写转换。</p>
<h2 id="SI和DI"><a href="#SI和DI" class="headerlink" title="SI和DI"></a>SI和DI</h2><p>si和di是8086CPU中和bx功能相近的两个寄存器，但是si和di不能分成两个8位寄存器来用。<br>除了用[bx或si或di]和[idata+bx或si或di]来指明一个内存单元，还可以用[bx+si]和[bx+di]的方式来指明内存单元。<br>[bx+si]表示一个偏移地址为(bx)+(si)的内存单元</p>
<h2 id="bx-si-idata-和-bx-di-idata"><a href="#bx-si-idata-和-bx-di-idata" class="headerlink" title="[bx+si+idata]和[bx+di+idata]"></a>[bx+si+idata]和[bx+di+idata]</h2><p>[bx+si+idata]表示偏移地址为(bx)+(si)+idata的内存单元，也可以写成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">[bx+idata+si]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">[idata+bx+si]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">idata[bx][si]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">[bx].idata[si]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">[bx][si].idata</span></pre></td></tr></table></figure>
<h2 id="不同寻址方式的灵活运用"><a href="#不同寻址方式的灵活运用" class="headerlink" title="不同寻址方式的灵活运用"></a>不同寻址方式的灵活运用</h2><p>当寄存器不够用时，就需要考虑使用内存，在需要暂存数据的时候，首先应该想到的是使用栈。</p>
<h1 id="第8章-数据处理的两个基本问题"><a href="#第8章-数据处理的两个基本问题" class="headerlink" title="第8章 数据处理的两个基本问题"></a>第8章 数据处理的两个基本问题</h1><p>数据处理的两个基本问题是：要处理的数据在什么地方？要处理的数据有多长？<br>reg表示寄存器，sreg表示段寄存器。</p>
<h2 id="bx、si、di和bp"><a href="#bx、si、di和bp" class="headerlink" title="bx、si、di和bp"></a>bx、si、di和bp</h2><p>8086CPU中，只有bx,si,di,bp可以放在[]中作为内存单元的偏移地址，这4个寄存器或单独使用，或组合使用，组合使用只有4种情况：bx和si，bx和di，bp和si，bp和di。如果使用了bp，并且没有显示给出段地址，那么段地址默认在SS中。</p>
<h2 id="机器指令处理的数据在什么地方"><a href="#机器指令处理的数据在什么地方" class="headerlink" title="机器指令处理的数据在什么地方"></a>机器指令处理的数据在什么地方</h2><p>绝大部分机器指令都是进行数据处理的指令，处理大致分为3类：读取，写入，运算。指令在执行前，所要处理的数据可以在3个地方：CPU内部，内存，端口。</p>
<h2 id="汇编语言中数据位置的表达"><a href="#汇编语言中数据位置的表达" class="headerlink" title="汇编语言中数据位置的表达"></a>汇编语言中数据位置的表达</h2><p>汇编语言用3个概念来表达数据的位置</p>
<h3 id="立即数（idata）"><a href="#立即数（idata）" class="headerlink" title="立即数（idata）"></a>立即数（idata）</h3><p>直接包含在机器指令中的数据，在汇编语言中称为立即数（idata），在汇编指令中直接给出，执行前在CPU的指令缓冲器中。</p>
<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>指令要处理的数据在寄存器中，在汇编指令中给出相应的寄存器名</p>
<h3 id="段地址和偏移地址"><a href="#段地址和偏移地址" class="headerlink" title="段地址和偏移地址"></a>段地址和偏移地址</h3><p>指令要处理的数据在内存中，在汇编指令中通过给出内存单元的段地址和偏移地址来指出，段地址可以在某个段寄存器中，可以显式或非显式给出</p>
<h2 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h2><p>定位内存单元的方法称为寻址方式，8086CPU的寻址方式如下表所示</p>
<p><img src="/2018/07/08/%E7%8E%8B%E7%88%BD%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/12-35-23.jpg" alt></p>
<h2 id="指令要处理的数据有多长"><a href="#指令要处理的数据有多长" class="headerlink" title="指令要处理的数据有多长"></a>指令要处理的数据有多长</h2><p>8086CPU的指令，可以处理两种尺寸的数据，byte和word。所以在指令中要指出进行的操作是字操作还是字节操作。</p>
<ul>
<li>通过寄存器名指明要处理的数据的尺寸</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">#字操作</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">mov ax,1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">#字节操作</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">mov al,1</span></pre></td></tr></table></figure>
<ul>
<li>在没有寄存器名存在的情况下，用操作符x ptr指明内存单元的长度，x可以是byte或word。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">#字操作</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">mov word ptr ds:[0],1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">#字节操作</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">mov byte ptr ds:[0],1</span></pre></td></tr></table></figure>
<p>在没有寄存器参与的内存单元的访问指令中，必须要用x ptr显式指明所要访问的内存单元长度，否则CPU无法得知要访问的是字单元还是字节单元。</p>
<ul>
<li>其他方法<br>有些指令默认了访问的单元是字单元还是字节单元，比如栈操作指令。</li>
</ul>
<h2 id="div指令"><a href="#div指令" class="headerlink" title="div指令"></a>div指令</h2><p>div是除法指令<br>除数：除数有8位和16位两种，存放在一个寄存器或内存单元中<br>被除数：默认放在AX和DX中。如果除数为8位，那么被除数为16位，默认放在AX中；如果除数为16位，那么被除数为32位，在DX和AX中存放，DX存放高16位，AX存放低16位。<br>结果：如果除数为8位，那么AL存放商，AH存放余数；如果除数为16位，那么AX存放商，DX存放余数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">div reg</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">div 内存单元</span></pre></td></tr></table></figure>
<h2 id="伪指令dd"><a href="#伪指令dd" class="headerlink" title="伪指令dd"></a>伪指令dd</h2><p>dd，用于定义双字型数据（dword，即double word）</p>
<h2 id="dup"><a href="#dup" class="headerlink" title="dup"></a>dup</h2><p>dup通常和db,dw,dd等数据定义的伪指令配合使用，用于进行数据的重复。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">db 重复的次数 dup (要重复的数据)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">dw 重复的次数 dup (要重复的数据)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">dd 重复的次数 dup (要重复的数据)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">#定义字节型数据，括号中的0,1,2被视作一个整体，前面的数字3表示这个整体要被dup重复3次。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">#所以最终是定义了9个字节型数据</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">db 3 dup (0,1,2)</span></pre></td></tr></table></figure>
<h1 id="第9章-转移指令的原理"><a href="#第9章-转移指令的原理" class="headerlink" title="第9章 转移指令的原理"></a>第9章 转移指令的原理</h1><p>可以修改IP，或同时修改CS和IP的指令统称为转移指令。<br>8086CPU的转移行为有以下几类：</p>
<ul>
<li>只修改IP，称为段内转移</li>
<li>同时修改CS和IP，称为段间转移</li>
</ul>
<p>由于转移指令对IP的修改范围不同，段内转移又分为：短转移和近转移。</p>
<ul>
<li>短转移IP的修改范围是-128~127</li>
<li>近转移IP的修改范围是-32768~32767</li>
</ul>
<p>8086CPU的转移指令分为以下几类：</p>
<ul>
<li>无条件转移指令</li>
<li>条件转移指令</li>
<li>循环指令</li>
<li>过程</li>
<li>中断</li>
</ul>
<h2 id="操作符offset"><a href="#操作符offset" class="headerlink" title="操作符offset"></a>操作符offset</h2><p>操作符offset是由编译器处理的符号，作用是取得标号的偏移地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">codesg segment</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">start: mov ax,offset start</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">s:mov ax,offset s</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">codesg ends</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">end start</span></pre></td></tr></table></figure>
<h2 id="jmp指令"><a href="#jmp指令" class="headerlink" title="jmp指令"></a>jmp指令</h2><p>jmp指令要给出两种信息：<br>转移的目的地址<br>转移的距离（段间转移，段内短转移，段内近转移）</p>
<h2 id="依据位移进行转移的jmp指令"><a href="#依据位移进行转移的jmp指令" class="headerlink" title="依据位移进行转移的jmp指令"></a>依据位移进行转移的jmp指令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">jmp short 标号（跳转到标号处执行指令）</span></pre></td></tr></table></figure>
<p>这种格式的jmp指令实现的是段内短转移，它对IP的修改范围是-128~127，也就是说，它向前转移时最多可以越过128个字节，向后转移最多越过127个字节。jmp指令中的short，说明指令进行的是短转移。标号说明了指令要转移的目的地，转移指令结束后CS:IP应指向标号处的指令。<br>在jmp short 标号所对应的机器码中，并不包含转移的目的地址，包含的是转移的位移。这个位移，是编译器根据汇编指令中的”标号”计算出来的。<br><code>jmp short 标号</code>执行后：（IP）=（IP）+8位位移。<br>8位位移=标号处的地址-jmp指令后第一个字节的地址<br>short指明此处的位移是8位位移<br>8位位移用补码表示，由编译器在编译时算出<br><code>jmp near ptr 标号</code>，实现的是段内近转移，（IP）=（IP）+16位位移。<br>16位位移=标号处的地址-jmp指令后第一个字节的地址<br>near ptr指明此处的位移是16位位移<br>16位位移用补码表示，由编译器在编译时计算得出</p>
<h2 id="转移的目的地址在指令中的jmp指令"><a href="#转移的目的地址在指令中的jmp指令" class="headerlink" title="转移的目的地址在指令中的jmp指令"></a>转移的目的地址在指令中的jmp指令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">jmp far ptr 标号</span></pre></td></tr></table></figure>
<p>实现的是段间转移，又称为远转移，指令执行后(CS)=标号所在段的段地址，(IP)=标号在段中的偏移地址</p>
<h2 id="转移地址在寄存器中的jmp指令"><a href="#转移地址在寄存器中的jmp指令" class="headerlink" title="转移地址在寄存器中的jmp指令"></a>转移地址在寄存器中的jmp指令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">jmp 16位寄存器</span></pre></td></tr></table></figure>
<h2 id="转移地址在内存中的jmp指令"><a href="#转移地址在内存中的jmp指令" class="headerlink" title="转移地址在内存中的jmp指令"></a>转移地址在内存中的jmp指令</h2><p>转移地址在内存中的jmp指令有两种格式：<br><code>jmp word ptr 内存单元</code>：用内存单元处的字修改IP，内存单元可用寻址方式的任意格式给出<br><code>jmp dword ptr 内存单元</code>:用内存单元高地址处的字修改CS，低地址处的字修改IP</p>
<h2 id="jcxz指令"><a href="#jcxz指令" class="headerlink" title="jcxz指令"></a>jcxz指令</h2><p>jcxz为有条件转移指令，所有的有条件转移指令都是短转移，对应的机器码中包含的是转移位移，而不是目的地址，对IP的修改范围是-128~127<br><code>jcxz 标号</code>:如果(cx)=0，则转移到标号处执行，否则什么也不做</p>
<h2 id="loop指令"><a href="#loop指令" class="headerlink" title="loop指令"></a>loop指令</h2><p>loop指令为循环指令，所有的循环指令都是短转移。<br><code>loop 标号</code>：(cx)=(cx)-1，如果(cx)!=0，则转移到标号执行，否则什么也不做</p>
<h2 id="编译器对转移位移超界的检测"><a href="#编译器对转移位移超界的检测" class="headerlink" title="编译器对转移位移超界的检测"></a>编译器对转移位移超界的检测</h2><p>根据位移进行转移的指令，他们的转移范围受到转移位移的限制，如果在源程序中出现了转移范围超界的问题，在编译的时候编译器会报错。</p>
<h1 id="第10章-CALL和RET指令"><a href="#第10章-CALL和RET指令" class="headerlink" title="第10章 CALL和RET指令"></a>第10章 CALL和RET指令</h1><h2 id="ret和retf"><a href="#ret和retf" class="headerlink" title="ret和retf"></a>ret和retf</h2><p>ret指令用栈中的数据修改IP，实现近转移，相当于POP IP<br>retf用栈中的数据修改CS和IP，实现远转移，相当于POP IP，POP CS</p>
<h2 id="call指令"><a href="#call指令" class="headerlink" title="call指令"></a>call指令</h2><p>CPU执行call指令时，进行两步操作</p>
<ul>
<li>将当前的IP或CS和IP压栈</li>
<li>转移</li>
</ul>
<p>即call指令执行时一定是先压栈再转移，call指令不能实现短转移，除此以外call指令实现转移的方法和jmp指令的原理相同。</p>
<h2 id="依据位移进行转移的call指令"><a href="#依据位移进行转移的call指令" class="headerlink" title="依据位移进行转移的call指令"></a>依据位移进行转移的call指令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">call 标号（将当前的IP压栈后，转到标号处执行）</span></pre></td></tr></table></figure>
<p>相当于：push IP,jmp near ptr 标号</p>
<h2 id="转移的目的地址在指令中的call指令"><a href="#转移的目的地址在指令中的call指令" class="headerlink" title="转移的目的地址在指令中的call指令"></a>转移的目的地址在指令中的call指令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">call far ptr 标号（实现的是段间转移）</span></pre></td></tr></table></figure>
<p>相当于push cs,push ip,jmp far ptr 标号，即CS,IP依次入栈后转移到标号处执行</p>
<h2 id="转移地址在寄存器中的call指令"><a href="#转移地址在寄存器中的call指令" class="headerlink" title="转移地址在寄存器中的call指令"></a>转移地址在寄存器中的call指令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">call 16位reg</span></pre></td></tr></table></figure>
<p>相当于：push ip,jmp 16位reg</p>
<h2 id="转移地址在内存的call指令"><a href="#转移地址在内存的call指令" class="headerlink" title="转移地址在内存的call指令"></a>转移地址在内存的call指令</h2><p>转移地址在内存中的call指令有两种格式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">call word ptr 内存单元地址</span></pre></td></tr></table></figure>
<p>相当于：push ip,jmp word ptr 内存单元地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">call dword ptr 内存单元地址</span></pre></td></tr></table></figure>
<p>相当于：push cs,push ip,jmp dword ptr 内存单元地址<br>汇编指令的长度与寻址方式有关：</p>
<ul>
<li>没有操作数的指令，长度为1字节</li>
<li>操作数只涉及寄存器的指令，长度为2字节</li>
<li>操作数涉及内存地址的指令，长度为3字节</li>
<li>操作数涉及立即数的指令，长度为寄存器类型+1,8位寄存器，寄存器类型为1，所以mov al,8的指令长度为2；16位寄存器，寄存器类型为2。</li>
<li>跳转指令分两种情况：段内跳转：段内短转移：8位位移量占1字节，jmp指令本身占1字节，所以整条指令长度为2字节；段内近转移：16位位移量为2字节，jmp指令占1字节，整条指令长度为3字节；段间跳转：指令长度为5字节。</li>
</ul>
<h2 id="call和ret的配合使用"><a href="#call和ret的配合使用" class="headerlink" title="call和ret的配合使用"></a>call和ret的配合使用</h2><p>可以写一个具有一定功能的程序段，称为子程序；在需要的时候用call指令去执行，子程序执行前，call指令后面的指令的地址将存于栈中，执行完之后可以在子程序的后面用ret指令返回，从而转到call指令后面的代码处继续执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">#子程序框架</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">标号：</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">指令</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">ret</span></pre></td></tr></table></figure>
<h2 id="mul指令"><a href="#mul指令" class="headerlink" title="mul指令"></a>mul指令</h2><p>mul是乘法指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">mul reg</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">mul 内存单元</span></pre></td></tr></table></figure>
<p>两个相乘的数要么都是8位，要么都是16位。如果是8位，一个默认存在AL中，另一个放在8位reg或内存字节单元中；如果是16位，一个默认在AX中，另一个放在16位reg或内存字单元中<br>8位乘法，结果默认放在AX中；16位乘法，结果高位默认放在DX中，低位放在AX中<br>内存单元可以用不同的寻址方式给出。</p>
<h2 id="批量数据的传递"><a href="#批量数据的传递" class="headerlink" title="批量数据的传递"></a>批量数据的传递</h2><p>当子程序需要的参数比较少时，可以存在寄存器中，但当子程序参数很多时，就需要将批量的数据存放到内存中，然后将它们所在内存空间的首地址放在寄存器中，传递给需要的子程序；对于具有批量数据的返回结果，也可以用同样的方法。<br>寄存器是有限的，大量数据的存放必然是在内存中。</p>
<h2 id="寄存器冲突的问题"><a href="#寄存器冲突的问题" class="headerlink" title="寄存器冲突的问题"></a>寄存器冲突的问题</h2><p>实际的编程中，可能出现这样的情况：子程序使用的寄存器，很可能在主程序中也要使用，这就造成了寄存器的冲突。解决的办法是：在子程序的开始将子程序中所有要用到的寄存器的内容都保存起来，在子程序返回前再恢复，寄存器的内容可以用栈来保存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">子程序开始：子程序使用的寄存器入栈</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">子程序内容</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">子程序使用的寄存器出栈</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">返回（ret、retf）</span></pre></td></tr></table></figure>
<h1 id="第11章-标志位寄存器"><a href="#第11章-标志位寄存器" class="headerlink" title="第11章 标志位寄存器"></a>第11章 标志位寄存器</h1><p>CPU内部的寄存器中，有一种特殊的寄存器，具有3种作用：</p>
<ul>
<li>用来存储相关指令的某些执行结果</li>
<li>用来为CPU执行相关指令提供行为依据</li>
<li>用来控制CPU的相关工作方式</li>
</ul>
<p>这种特殊的寄存器在8086CPU中被称为标志寄存器。8086CPU的标志寄存器有16位，其中存储的信息被称为程序状态字（PSW），标志寄存器是按位起作用的，它的每一位都有专门的含义，记录特定的信息，标志寄存器的结构如下：<br><img src="/2018/07/08/%E7%8E%8B%E7%88%BD%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/11-07-33.jpg" alt><br>只有0,2,4,6,7,8,9,10,11位有意义，其余几位没有使用。</p>
<h2 id="ZF标志"><a href="#ZF标志" class="headerlink" title="ZF标志"></a>ZF标志</h2><p>ZF是零标志位，它记录相关指令执行后，结果是否为0，如果结果为0，那么ZF=1，否则ZF=0。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">#指令执行后，结果为0，所以ZF&#x3D;1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">mov ax,1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">sub ax,1</span></pre></td></tr></table></figure>
<p>在8086CPU的指令集中，有的指令的执行是影响标志寄存器的，比如：add,sub,mul,div,inc,or,and等，它们大都是运算指令（算术或逻辑运算），有的指令的执行对标志寄存器没有影响，如：mov,push,pop等，大都是传送指令。在使用一条指令的时候，要注意这些指令的全部功能，其中包括执行结果对标志寄存器的哪些标志位造成影响。</p>
<h2 id="PF标志"><a href="#PF标志" class="headerlink" title="PF标志"></a>PF标志</h2><p>PF是奇偶标志位，用于记录相关指令执行后，结果的所有bit位中1的个数是否为偶数，如果是偶数，pf=1，否则pf=0.</p>
<h2 id="SF标志"><a href="#SF标志" class="headerlink" title="SF标志"></a>SF标志</h2><p>SF是符号标志位，记录相关指令执行后，结果是否为负，如果为负，sf=1，否则sf=0<br>计算机中通常用补码来表示有符号数据，计算机中的一个数据可以看做有符号数，也可以看做无符号数。<br>SF标志，就是CPU对有符号数运算结果的一种记录，它记录数据的正负，在我们将数据当做有符号数来运算的时候，可以通过它来得知结果的正负。如果我们将数据当做无符号数据运算，SF的值则没有意义，虽然相关指令影响了它的值。也就是说，CPU在执行add等指令时，必然会影响到SF的值，至于我们需不需要这种影响，取决于我们如何看待指令所进行的运算。</p>
<h2 id="CF标志"><a href="#CF标志" class="headerlink" title="CF标志"></a>CF标志</h2><p>CF是进位标志位，无符号运算时，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值。<br>对于位数为N的无符号数而言，其对应的二进制信息的最高位，即第N-1位，就是它的最高有效位，而假想存在的第N位，就是相对于最高有效位的更高位<br><img src="/2018/07/08/%E7%8E%8B%E7%88%BD%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/11-39-15.jpg" alt><br>当两个数据相加时，有可能产生从最高有效位向更高位的进位，CPU在运算时，并不丢弃这个进位值，而是保存到CF上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">#执行后，(al)&#x3D;30H,CF&#x3D;1,CF记录了从最高有效位向更高位的进位值</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">mov al,98H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">add al,al</span></pre></td></tr></table></figure>
<p>当两个数据相减时，有可能向更高位借位，CF也可以用来记录这个借位值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">mov al,97H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">#执行后，(al)&#x3D;FFH,CF&#x3D;1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">sub al,98H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">#(al)&#x3D;0,CF&#x3D;0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">sub al,al</span></pre></td></tr></table></figure>
<h2 id="OF标志"><a href="#OF标志" class="headerlink" title="OF标志"></a>OF标志</h2><p>在进行有符号数运算的时候，如果超过了机器所能表示的范围称为溢出。<br>OF是溢出标志位，记录有符号数运算的结果是否发生溢出，如果溢出OF=1，否则OF=0<br>CPU在执行add等运算指令时，存在两种含义，无符号数运算和有符号数运算，如果看做无符号数则关注与无符号运算有关的寄存器，当做有符号数则关注与有符号运算有关的寄存器，CF和OF所表示的进位和溢出，是分别针对无符号数和有符号数运算而言的，它们之间没有任何关系。<br>是否溢出要将结果转为10进制来看是否在非溢出的范围，8位是-128<del>127,16位是-32768</del>32767</p>
<h2 id="adc指令"><a href="#adc指令" class="headerlink" title="adc指令"></a>adc指令</h2><p>adc是带进位加法指令，它利用了CF位上的进位值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">adc 操作对象1,操作对象2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">功能：操作对象1&#x3D;操作对象1+操作对象2+CF</span></pre></td></tr></table></figure>
<p>执行adc指令时所加的CF的值，其含义是由adc前面的指令决定的，即关键在于CF的值是被什么指令设置的，如果是被sub指令设置的，那么它的含义就是借位值，如果是被add指令设置的，那么就是进位值。<br>adc指令执行后，也可能产生进位值，所以也会对CF位进行设置。</p>
<h2 id="sbb指令"><a href="#sbb指令" class="headerlink" title="sbb指令"></a>sbb指令</h2><p>sbb是带借位减法指令，利用了CF位上的借位值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">sbb 操作对象1,操作对象2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">功能：操作对象1&#x3D;操作对象1-操作对象2-CF</span></pre></td></tr></table></figure>
<h2 id="cmp指令"><a href="#cmp指令" class="headerlink" title="cmp指令"></a>cmp指令</h2><p>cmp是比较指令，其功能相当于减法指令，但是不保存结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">cmp 操作对象1,操作对象2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">功能：计算操作对象1-操作对象2，但并不保存结果，只根据结果对标志位寄存器进行设置</span></pre></td></tr></table></figure>
<p>cpu在执行cmp指令的时候，也包含两种含义：无符号运算和有符号运算。<br>两个有符号数A,B相减，得到负数，那么A&lt;B，但是关键在于根据什么来判断得到的结果是否是负数。单纯地根据SF的值不可能知道结果的正负，因为SF记录的只是在计算机中可以存的下的数据的正负，但这个能存下来的值并不一定是运算结果的真正值，因为真正的运算结果是可能存在溢出的。所以，应该同时根据SF和OF来进行判断。<br>如果因为溢出导致了所得结果为负，那么真正结果必然为正<br>如果因为溢出导致了所得结果为正，那么真正结果必然为负</p>
<h2 id="检测比较结果的条件转移指令"><a href="#检测比较结果的条件转移指令" class="headerlink" title="检测比较结果的条件转移指令"></a>检测比较结果的条件转移指令</h2><p>条件转移，是指可以根据某种条件，来决定是否修改IP。<br>jcxz：如果(cx)=0，就修改IP，否则什么也不做，所有条件转移指令的转移位移都是[-128,127]<br>大多数条件转移指令都检测标志位寄存器的相关标志位，根据检测结果来决定是否修改IP，它们检测的标志位就是被cmp指令影响的那些表示比较结果的标志位，这些条件转移指令通常都和cmp指令配合使用。<br>因为cmp指令可以同时进行两种比较，所以条件转移指令也有两种：根据无符号数的比较结果进行的转移（检测zf,cf位）和根据有符号数的比较结果进行的转移（检测sf,of,zf位）。<br><img src="/2018/07/08/%E7%8E%8B%E7%88%BD%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/18-00-40.jpg" alt><br><img src="/2018/07/08/%E7%8E%8B%E7%88%BD%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/18-00-57.jpg" alt><br>虽然je的含义是相等则转移，但它进行的操作是ZF=1时转移，相等则转移这种含义是通过和cmp配合使用来体现的，因为cmp为zf=1赋予了两数相等的含义。<br>在je之前是否使用cmp指令，在于我们的安排，je检测的是zf位，不管je前面是什么指令，只要CPU执行je时，zf=1，就会发生转移。</p>
<h2 id="DF标志和串传送指令"><a href="#DF标志和串传送指令" class="headerlink" title="DF标志和串传送指令"></a>DF标志和串传送指令</h2><p>DF：方向标志位，在串处理指令中，控制每次操作后si,di的增减。<br>df=0：每次操作后si,di递增<br>df=1：每次操作后si,di递减<br>串传送指令：movsb；功能：将ds:si指向的内存单元中的字节送入es:di中，然后根据df的值将si,di递增或递减<br>movsw:将ds:si指向的内存单元的字送入es:di，然后根据df的值将si,di递增2或递减2<br>一般来说，movsb和movsw都和rep配合使用：<code>rep movsb</code>，rep的作用是根据cx的值，重复执行后面的串传送指令，可以循环实现(cx)个字符的传送</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">cld:将df位置0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">std:将df位置1</span></pre></td></tr></table></figure>
<h2 id="pushf和popf"><a href="#pushf和popf" class="headerlink" title="pushf和popf"></a>pushf和popf</h2><p>pushf：标志位寄存器的值压栈<br>popf:数据出栈送入标志位寄存器</p>
<h1 id="第12章-内中断"><a href="#第12章-内中断" class="headerlink" title="第12章 内中断"></a>第12章 内中断</h1><p>任何一个通用的CPU，都具备一种能力，可以在执行完当前正在执行的指令之后，检测到从CPU外部发送过来的或CPU内部产生的一种特殊信息，并立即对这种信息进行处理，这种特殊的信息称为中断信息。中断是指CPU不再接着刚执行完的指令向下执行，而是转去处理这个特殊信息。</p>
<h2 id="内中断的产生"><a href="#内中断的产生" class="headerlink" title="内中断的产生"></a>内中断的产生</h2><p>CPU内部产生的中断称为内中断。不同的中断信息，就需要进行不同的处理，要进行不同的处理，CPU就要先知道中断信息的来源（即中断源）。8086CPU用称为中断类型码的数据来表示中断信息的来源，中断类型码是一个字节型数据，可以表示256种中断源。<br>8086CPU的内中断有以下几种</p>
<ul>
<li>除法错误 0</li>
<li>单步执行 1</li>
<li>执行into指令 4</li>
<li>执行int指令，int指令的格式为int n，n是字节型立即数，也是提供给CPU的中断类型码</li>
</ul>
<h2 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h2><p>用来处理中断信息的程序称为中断处理程序</p>
<h2 id="中断向量表"><a href="#中断向量表" class="headerlink" title="中断向量表"></a>中断向量表</h2><p>中断向量就是中断处理程序的入口地址，中断向量表，就是存放中断处理程序入口地址的列表。<br><img src="/2018/07/08/%E7%8E%8B%E7%88%BD%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/19-15-23.jpg" alt><br>CPU用中断类型码在中断向量表中找到中断处理程序的入口地址。<br>中断向量表保存在内存中，对于8086PC机，中断向量表指定放在内存地址0处，从0000:0000到0000:03FF中存放中断向量表，并且不能放在其他地方。一个表项存放一个中断向量，包括段地址和偏移地址，所以一个表项占两个字，高地址字存放段地址，低地址字存放偏移地址。</p>
<h2 id="中断过程"><a href="#中断过程" class="headerlink" title="中断过程"></a>中断过程</h2><p>找到中断向量后并用它设置CS和IP，这个工作是由CPU的硬件自动完成的，CPU硬件完成这个工作的工程被称为中断过程。<br>整个中断过程如下：</p>
<ul>
<li>取得中断类型码</li>
<li>标志寄存器的值入栈（因为在中断过程中要改变标志寄存器，所以要先保存一份原值）</li>
<li>设置标志寄存器的TF和IF位为0</li>
<li>CS入栈</li>
<li>IP入栈</li>
<li>从内存地址为中断类型码<em>4和中断类型码</em>4+2的两个字单元中读取中断处理程序的入口地址，设置CS和IP</li>
</ul>
<p>中断过程的主要任务就是根据中断类型码取得中断向量，设置CS和IP。执行完中断处理程序后，需要恢复在进入中断处理程序之前的CPU现场（某一时刻，CPU中个寄存器的值），所以应该在修改标志寄存器之前，将其值入栈。</p>
<h2 id="中断处理程序和iret指令"><a href="#中断处理程序和iret指令" class="headerlink" title="中断处理程序和iret指令"></a>中断处理程序和iret指令</h2><p>中断处理程序的编写方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">保存用到的寄存器</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">处理中断</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">恢复用到的寄存器</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">用iret指令返回</span></pre></td></tr></table></figure>
<p>iret通常和硬件自动完成的中断过程配合使用，iret的功能相当于：pop IP,pop CS,popf<br>要让一段程序成为N号中断的中断处理程序，就将它的入口地址放入中断向量表的N号表项中。<br>“-“是编译器识别的运算符，可以用来进行减法运算，汇编编译器可以处理运算表达式</p>
<h2 id="单步中断"><a href="#单步中断" class="headerlink" title="单步中断"></a>单步中断</h2><p>CPU在执行完一条指令之后，如果检测到标志寄存器的TF位为1，则产生单步中断，单步中断的中断类型码为1，引发的中断过程如下</p>
<ul>
<li>取得中断类型码1</li>
<li>标志寄存器入栈，TF,IF置0</li>
<li>CS,IP入栈</li>
<li>(IP)=1<em>4 (CS)=1</em>4+2</li>
</ul>
<p>在进入中断处理程序之前，设置TF=0，从而避免CPU在执行中断处理程序的时候发生单步中断。这就是为什么中断过程中有TF=0这个步骤</p>
<h2 id="响应中断的特殊情况"><a href="#响应中断的特殊情况" class="headerlink" title="响应中断的特殊情况"></a>响应中断的特殊情况</h2><p>某些情况下，CPU执行完当前指令后，即使发生中断，CPU也不会响应。</p>
<h1 id="第13章-int指令"><a href="#第13章-int指令" class="headerlink" title="第13章 int指令"></a>第13章 int指令</h1><h2 id="int指令"><a href="#int指令" class="headerlink" title="int指令"></a>int指令</h2><p>CPU执行int n指令，相当于引发一个n号中断，过程如下</p>
<ul>
<li>取中断类型码n</li>
<li>标志寄存器入栈，IF=0,TF=0</li>
<li>CS,IP入栈</li>
<li>(IP)=(n<em>4) (CS)=(n</em>4+2)</li>
</ul>
<p>int指令的最终功能和call指令相似，都是调用一段程序<br>一般情况下，系统将一些具有一定功能的子程序，以中断处理程序的方式提供给应用程序调用。我们在编程的时候，可以用int指令调用这些子程序，中断处理程序也简称为中断例程。</p>
<h2 id="BIOS和DOS所提供的中断例程"><a href="#BIOS和DOS所提供的中断例程" class="headerlink" title="BIOS和DOS所提供的中断例程"></a>BIOS和DOS所提供的中断例程</h2><p>在系统板的ROM中存放着一套程序，称为BIOS，BIOS中主要包含以下几部分</p>
<ul>
<li>硬件系统的检测和初始化程序</li>
<li>外部中断和内部中断的中断例程</li>
<li>用于对硬件设备进行I/O操作的中断例程</li>
<li>其他和硬件系统相关的中断例程</li>
</ul>
<p>和硬件设备相关的DOS中断例程，一般都调用了BIOS的中断例程</p>
<h2 id="BIOS和DOS中断例程的安装过程"><a href="#BIOS和DOS中断例程的安装过程" class="headerlink" title="BIOS和DOS中断例程的安装过程"></a>BIOS和DOS中断例程的安装过程</h2><p>开机后，CPU一加电，初始化(CS)=0FFFFH,(IP)=0，FFFF:0处有一条跳转指令，CPU执行该指令后，转去执行BIOS中的硬件系统检测和初始化程序。<br>初始化程序将建立BIOS所支持的中断向量，即将BIOS提供的中断例程的入口地址登记在中断向量表中。对于BIOS所提供的中断例程，只需将入口地址登记在中断向量表中即可，因为它们是固化到ROM中的程序，一直在内存中存在。<br>硬件系统检测和初始化完成后，调用int 19h进行操作系统的引导，从此将计算机交给操作系统控制<br>DOS启动后，除完成其他工作外，还将它所提供的中断例程装入内存，并建立相应的中断向量。</p>
<h2 id="BIOS中断例程应用"><a href="#BIOS中断例程应用" class="headerlink" title="BIOS中断例程应用"></a>BIOS中断例程应用</h2><p>一个中断例程往往包含多个子程序，中断例程内部用传递进来的参数来决定执行哪一个子程序。BIOS和DOS提供的中断例程，都用ah来传递内部子程序的编号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">#(ah)&#x3D;2，表示调用第10h号中断例程中的2号子程序，(bh)&#x3D;0,(dh)&#x3D;5,(dl)&#x3D;12为传给2号子程序的参数。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">mov ah,2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">mov bh,0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">mov dh,5</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">mov dl,12</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">int 10h</span></pre></td></tr></table></figure>
<h1 id="第14章-端口"><a href="#第14章-端口" class="headerlink" title="第14章 端口"></a>第14章 端口</h1><p>在PC机系统中，和CPU通过总线相连的芯片除各种存储器外，还有3种芯片</p>
<ul>
<li>各种接口卡上的接口芯片，它们控制接口卡进行工作</li>
<li>主板上的接口芯片，CPU通过它们对部分外设进行访问</li>
<li>其他芯片，用来存储相关的系统信息，或进行相关的输入输出处理</li>
</ul>
<p>在这些芯片中，都有一组可以由CPU读写的寄存器，这些寄存器它们在物理上可能处于不同的芯片中，但是在以下两点上相同</p>
<ul>
<li>都和CPU的总线相连，这种连接是通过它们所在的芯片进行的</li>
<li>CPU对他们进行读写的时候都通过控制线向它们所在的芯片发出端口读写命令</li>
</ul>
<p>可见，从CPU的角度，将这些寄存器都当做端口，对他们进行统一编址，从而建立了一个统一的端口地址空间。<br>CPU可以直接读写以下3个地方的数据</p>
<ul>
<li>CPU内部的寄存器</li>
<li>内存单元</li>
<li>端口：即芯片中的寄存器</li>
</ul>
<h2 id="端口的读写"><a href="#端口的读写" class="headerlink" title="端口的读写"></a>端口的读写</h2><p>CPU通过端口地址来定位端口，因为端口所在的芯片和CPU通过总线相连，所以端口地址和内存地址一样通过地址总线来传送。PC系统中，CPU最多可以定位64KB个不同端口，所以端口地址的范围是0~65535.<br>端口的读写指令只有两条：in和out，分别用于从端口读数据和往端口写入数据。<br>在in和out指令中，只能使用al或ax来存放从端口读入的数据或要发送到端口中的数据，访问8位端口时用al，访问16位端口时用ax。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">#对0~255以内的端口进行读写时</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">in al,20h  ;从20h端口读入一个字节</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">out 20h,al  ;往20h端口写入一个字节</span></pre></td></tr></table></figure>
<p>对256~65535的端口进行读写时，端口号放在dx中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">mov dx,3f8h</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">in al,dx</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">out dx,al</span></pre></td></tr></table></figure>
<h2 id="CMOS-RAM芯片"><a href="#CMOS-RAM芯片" class="headerlink" title="CMOS RAM芯片"></a>CMOS RAM芯片</h2><p>PC机中，有一个CMOS RAM芯片，简称CMOS，其特征如下：</p>
<ul>
<li>包含一个实时钟和一个有128个存储单元的RAM存储器</li>
<li>该芯片靠电池供电，所以关机后其内部时钟仍然可以正常工作，RAM中的信息不会丢失</li>
<li>128个字节的RAM中，内部时钟占用0~0dh单元来保存时间信息，其余大部分单元用于保存系统配置信息，供系统启动时BIOS程序读取。BIOS也提供了相关的程序，使我们可以在开机的时候配置CMOS中的系统信息</li>
<li>该芯片内部有两个端口，端口地址为70h和71h。CPU通过这两个端口来读写CMOS</li>
<li>70h为地址端口，存放要访问的CMOS单元地址，71h为数据端口，存放从选定的CMOS单元中读出的数据，或者将要写入的数据</li>
</ul>
<h2 id="shl和shr指令"><a href="#shl和shr指令" class="headerlink" title="shl和shr指令"></a>shl和shr指令</h2><p>shl是逻辑左移指令，功能为：</p>
<ul>
<li>将一个寄存器或内存单元中的数据向左移位</li>
<li>将最后移出的一位写入CF中</li>
<li>最低位用0补充</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">#执行后(al)&#x3D;1001000b,CF&#x3D;0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">mov al,01001000b</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">shl al,1</span></pre></td></tr></table></figure>
<p>如果移动位数大于1，必须将移动位数放在cl中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">#执行后(al)&#x3D;10001000b，因为最后移出的一位是0，所以CF&#x3D;0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">mov al,01010001b</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">mov cl,3</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">shl al,cl</span></pre></td></tr></table></figure>
<p>shr是逻辑右移指令，功能为：</p>
<ul>
<li>将一个寄存器或内存单元中的数据向右移位</li>
<li>最后移出的一位写入CF中</li>
<li>最高位用0补充</li>
</ul>
<p>移动位数大于1时，必须放在cl中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">#执行后(al)&#x3D;00001010b，最后移出的一位是0，所以CF&#x3D;0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">mov al,01010001b</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">mov cl,3</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">shr al,cl</span></pre></td></tr></table></figure>
<h2 id="CMOS-RAM中存储的时间信息"><a href="#CMOS-RAM中存储的时间信息" class="headerlink" title="CMOS RAM中存储的时间信息"></a>CMOS RAM中存储的时间信息</h2><p>CMOS RAM中存放着当前时间，精确到秒，这些数据以BCD码表示，所谓BCD码，就是以4位二进制数表示十进制数。如2是0010,6是0110，所以26就是00100110</p>
<h1 id="第15章-外中断"><a href="#第15章-外中断" class="headerlink" title="第15章 外中断"></a>第15章 外中断</h1><h2 id="接口芯片和端口"><a href="#接口芯片和端口" class="headerlink" title="接口芯片和端口"></a>接口芯片和端口</h2><p>外设的输入不直接送入内存和CPU，而是送入相关的接口芯片的端口中；CPU向外设的输出也不是直接送入外设，而是先送入端口，再由相关的芯片送到外设。CPU还可以向外设输出控制命令，而这些控制命令也是先送到相关芯片的端口中，然后再由相关的芯片根据命令对外设实施控制。可见，CPU通过端口和外部设备进行联系。</p>
<h2 id="外中断信息"><a href="#外中断信息" class="headerlink" title="外中断信息"></a>外中断信息</h2><p>当CPU外部有需要处理的事情发生时，相关芯片将向CPU发出相应的中断信息，CPU执行完当前指令后，可以检测到发送过来的中断信息，引发中断过程。<br>PC系统中，外中断源有两类：</p>
<ul>
<li>可屏蔽中断</li>
</ul>
<p>可屏蔽中断是CPU可以不响应的外部中断。CPU是否响应可屏蔽中断，要看标志寄存器的IF位。当CPU检测到可屏蔽中断时，如果IF=1，响应中断，IF=0则不响应中断。<br>可屏蔽中断信息来自CPU外部，中断类型码是通过数据总线送入CPU的，而内中断的中断类型码是在CPU内部产生的。<br>中断过程中将IF置0，是为了禁止其他的可屏蔽中断。<br>如果在中断处理程序中需要处理可屏蔽中断，可以用指令将IF置1.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">sti：设置IF&#x3D;1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">cli：设置IF&#x3D;0</span></pre></td></tr></table></figure>
<ul>
<li>不可屏蔽中断</li>
</ul>
<p>不可屏蔽中断是CPU必须响应的外中断。当CPU检测到不可屏蔽中断信息时，在执行完当前指令后立即响应，引发中断过程。<br>对于8086CPU，不可屏蔽中断的中断类型码固定为2，所以在中断过程中，不需要取中断类型码。不可屏蔽中断的过程为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">标志寄存器入栈，IF&#x3D;0,TF&#x3D;0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">CS,IP入栈</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">(IP)&#x3D;(8),(CS)&#x3D;(0AH)</span></pre></td></tr></table></figure>
<p>几乎所有由外设引发的外中断，都是可屏蔽中断。当外设有需要处理的事件发生时，相关芯片向CPU发出可屏蔽中断信息。不可屏蔽中断是在系统中有必须处理的紧急情况发生时用来通知CPU的中断信息。</p>
<h2 id="PC机键盘的处理过程"><a href="#PC机键盘的处理过程" class="headerlink" title="PC机键盘的处理过程"></a>PC机键盘的处理过程</h2><p>键盘上的每一个键相当于一个开关，键盘中有一个芯片对每一个键的开关状态进行扫描。<br>按下一个键时，开关接通，该芯片就产生一个扫描码，扫描码说明了按下的键在键盘上的位置。扫描码被送入主板上相关接口芯片的寄存器中，该寄存器的端口地址为60H。<br>松开按下的键时，也产生一个扫描码，扫描码说明了松开的键在键盘上的位置，松开按键时产生的扫描码也被送入60H端口中。<br>一般将按下一个键时产生的扫描码称为通码，松开一个键产生的扫描码称为断码，扫描码长度为一个字节，通码第7位为0，断码第7位为1.断码=通码+80H<br>BIOS键盘缓冲区是系统启动后，BIOS用于存放int 9中断例程所接收的键盘输入的内存区，该内存区可以存储15个键盘输入，因为int 9中断例程除了接收扫描码外，还要产生和扫描码对应的字符，所以在BIOS键盘缓冲区中，一个键盘输入用一个字单元存放，高位字节存放扫描码，低位字节存放字符码。</p>
<h1 id="第16章-直接定址表"><a href="#第16章-直接定址表" class="headerlink" title="第16章 直接定址表"></a>第16章 直接定址表</h1><h2 id="描述了单元长度的标号"><a href="#描述了单元长度的标号" class="headerlink" title="描述了单元长度的标号"></a>描述了单元长度的标号</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">code segment</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">a:db 1,2,3,4,5,6,7,8</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">b:dw 0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">code ends</span></pre></td></tr></table></figure>
<p>标号a,b仅仅表示内存单元的地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">code segment</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">a db 1,2,3,4,5,6,7,8</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">b dw 0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">code ends</span></pre></td></tr></table></figure>
<p>程序中的标号a,b后面没有”:”，这种标号称为数据标号，数据表号标记了存储数据的内存单元的地址和长度。标号a，描述了地址code:0，和从这个地址开始以后的内存单元都是字节单元；标号b描述了地址code:8，和从这个地址开始以后的内存单元都是字单元。</p>
<h2 id="在其他段中使用数据标号"><a href="#在其他段中使用数据标号" class="headerlink" title="在其他段中使用数据标号"></a>在其他段中使用数据标号</h2><p>一般来说，我们不在代码段中定义数据，而是将数据定义到其他段中，在其他段中我们也可以使用数据标号来描述存储数据的内存单元的地址和长度。<br>后面带有”:”的地址标号，只能在代码段中使用。<br>如果想在代码段中直接用数据标号访问数据，则需要用assume指令将标号所在的段和一个段寄存器联系在一起，否则编译器在编译时无法确定标号的段地址在哪一个寄存器中。但是这种联系是编译器需要的，并不是说，用assume将段寄存器和某个段联系起来之后，段寄存器就存放了这个段的地址，我们仍然需要在代码中用指令对段寄存器进行设置。<br>可以将标号当做数据来定义，此时，编译器将标号所表示的地址当做数据的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">#数据标号c处存储的两个字型数据为标号a,b的偏移地址，相当于 c dw offset a,offset b</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">data segment</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">a db 1,2,3,4,5,6,7,8</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">b dw 0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">c dw a,b</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">data ends</span></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">#数据标号c处存储的两个双字型数据为标号a的偏移地址和段地址，标号b的偏移地址和段地址</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">#相当于 c dw offset a,seg a,offset b,seg b</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">data segment</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">a db 1,2,3,4,5,6,7,8</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">b dw 0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">c dd a,b</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">data ends</span></pre></td></tr></table></figure>

<h1 id="第17章-使用BIOS进行键盘输入和磁盘读写"><a href="#第17章-使用BIOS进行键盘输入和磁盘读写" class="headerlink" title="第17章 使用BIOS进行键盘输入和磁盘读写"></a>第17章 使用BIOS进行键盘输入和磁盘读写</h1><h2 id="应用int-13h中断例程对磁盘进行读写"><a href="#应用int-13h中断例程对磁盘进行读写" class="headerlink" title="应用int 13h中断例程对磁盘进行读写"></a>应用int 13h中断例程对磁盘进行读写</h2><p>磁盘的实际访问由磁盘控制器进行，我们可以通过控制磁盘控制器来访问磁盘。只能以扇区为单位对磁盘进行读写。在读写扇区的时候，要给出面号，磁道号和扇区号。面号和磁道号从0开始，而扇区号从1开始。</p>
</div><div class="post-copyright"><div class="post-copyright-author"><span class="post-copyright-meta">本文作者: </span><span class="post-copyright-info"><a href="mailto:undefined" target="_blank" rel="noopener">l34rner</a></span></div><div class="post-copyright-type"><span class="post-copyright-meta">本文链接: </span><span class="post-copyright-info"><a href="/http:/yoursite.com/2018/07/08/%E7%8E%8B%E7%88%BD%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/">http://yoursite.com/2018/07/08/%E7%8E%8B%E7%88%BD%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright-notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com">一个记录自己学习轨迹的自娱自乐之地</a>！</span></div></div></article><div id="pagination"></div><!--div!= paginator()--></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fas fa-file-o"></i></span><span id="busuanzi_value_page_pv"></span><span></span></div><div class="copyright">&copy;2017 ～ 2019 By l34rner</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/copy.js"></script><!--script(src=url)--></body></html>